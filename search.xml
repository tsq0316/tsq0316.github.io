<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C#委托与事件讲解</title>
    <url>/2023/10/22/CSharp/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>本文将详细介绍一下C#中的委托是什么，委托的分类，委托的适用情形和使用要求，委托的多播，以及事件机制，以帮助大家更深入地理解委托机制。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们首先试想一下这种业务场景：假设你正在编写一个闹钟设置程序，你可以为不同行为设置不同的闹钟内容，允许用户设置不同的活动提醒，该怎么做呢？<br>我们可能会定义一个闹钟类，并为这个类添加很多方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AlarmClock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetWorkAlarm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置工作提醒音乐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetExerciseAlarm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置锻炼提醒音乐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetRelaxAlarm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置放松提醒音乐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法有显而易见的弊端，我们必须编写多个方法来处理不同的提醒音乐，导致代码冗余，而且当我们在不同地方，试图加入更多的闹钟行为时，必须要修改AlarmClock类，这也不便于代码管理。<br>假设此时，我们可以有一个通用的方法，将不同的提醒音乐表示成一个委托，在具体使用时定义委托的内容，是不是可以更加灵活，也减少了代码重复呢？</p>
<h2 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h2><p>此时就要提到C#中一种强大的特性：<strong>委托</strong>。熟悉面向对象的话，可以把委托粗暴理解为方法的抽象，即一个方法的模板，具体是怎么样的，由这个方法自己去实现。使用时不直接执行这个方法，而是通过调用委托来执行这个方法。<br>委托简单来说可以理解为指向一个或者一组方法的指针，用于声明和处理方法引用，如果没有函数指针的概念，可以更简单地理解为委托就是一类相同类型函数（参数列表和返回值类型一致）的引用。<br>委托是C#中的一种类型，它允许将方法作为参数传递，存储对方法的引用，并在运行时动态选择要执行的方法。委托以特定的方法签名（返回类型和参数列表）来声明，可以用于表示一类方法，而不是特定的具体的方法。</p>
<blockquote>
<p>委托类似于函数指针，但更加类型安全和面向对象。函数指针只能引用静态方法，委托可以引用实例和静态方法。</p>
</blockquote>
<h2 id="委托的类型和使用方式"><a href="#委托的类型和使用方式" class="headerlink" title="委托的类型和使用方式"></a>委托的类型和使用方式</h2><p>委托分为<strong>系统内置委托</strong>和<strong>自定义委托</strong>。系统内置委托是 .NET Framework提供的一组常用委托类型，而自定义委托是开发人员自己定义的委托类型，以满足特定需求。在使用委托的时候，可以像对待一个类一样对待它。即<strong>先声明，再实例化</strong>。</p>
<h3 id="系统内置委托"><a href="#系统内置委托" class="headerlink" title="系统内置委托"></a>系统内置委托</h3><p>这些内置委托类型具有特定的方法签名，使其适用于各种情况。</p>
<h4 id="Action委托"><a href="#Action委托" class="headerlink" title="Action委托"></a>Action委托</h4><ul>
<li><p>用途：Action 委托表示一个不带返回值的委托，用于执行操作而不返回结果。</p>
</li>
<li><p>方法签名：<code>Action</code> 委托可以接受零到六个参数，具体取决于不同重载。通常，Action 委托没有参数，例如 <code>Action action = () =&gt; &#123; /* 执行操作 */ &#125;</code>;。</p>
</li>
<li><p>示例：以下是一个示例，演示了 Action 委托的用法。这里我们定义一个 Action 委托并将其绑定到一个方法，然后调用 Action 委托执行操作。<br>不带参数的Action委托：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action action = () =&gt; Console.WriteLine(<span class="string">&quot;这是一个操作。&quot;</span>);</span><br><span class="line">action(); <span class="comment">// 输出：这是一个操作。</span></span><br></pre></td></tr></table></figure>

<p>带参数的Action委托:</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; action = (message) =&gt; Console.WriteLine(message);</span><br><span class="line">action(<span class="string">&quot;这是一个操作。&quot;</span>); <span class="comment">// 输出：这是一个操作。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Func委托"><a href="#Func委托" class="headerlink" title="Func委托"></a>Func委托</h4><ul>
<li><p>用途：Func 委托表示带有返回值的委托，用于执行操作并返回结果。</p>
</li>
<li><p>方法签名：<code>Func</code> 委托可以接受零到六个参数，具体取决于不同重载。最后一个参数表示返回值类型。例如<code>Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b</code>; 表示一个接受两个整数参数并返回整数结果的委托。</p>
</li>
<li><p>示例：以下是一个示例，演示了 Func 委托的用法。这里我们定义一个 Func 委托，并将其绑定到一个方法，然后调用 Func 委托执行操作并返回结果。</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br><span class="line"><span class="built_in">int</span> result = <span class="keyword">add</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 执行操作并返回结果，打印 result 等于 8</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Predicate-委托"><a href="#Predicate-委托" class="headerlink" title="Predicate 委托"></a>Predicate 委托</h4><ul>
<li><p>用途：Predicate 委托表示一个返回布尔值的委托，通常用于测试条件。</p>
</li>
<li><p>方法签名：<code>Predicate&lt;T&gt;</code> 委托表示接受一个泛型参数 T 并返回布尔值的委托。例如，<code>Predicate&lt;int&gt; isEven = n =&gt; n % 2 == 0</code>; 表示一个用于检查整数是否为偶数的委托。</p>
</li>
<li><p>示例：以下是一个示例，演示了 Predicate 委托的用法。这里我们定义一个 Predicate 委托并将其绑定到一个方法，然后使用 Predicate 委托测试条件。</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">int</span>&gt; isEven = n =&gt; n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> result = isEven(<span class="number">6</span>); <span class="comment">// 使用 Predicate 委托测试条件，打印 result 为 true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="EventHandler-委托"><a href="#EventHandler-委托" class="headerlink" title="EventHandler 委托"></a>EventHandler 委托</h4><p>  此处简单介绍一下事件，具体什么是事件，之后会详细介绍。</p>
<ul>
<li><p>用途：EventHandler 委托通常用于处理事件，用于订阅和取消订阅事件。</p>
</li>
<li><p>方法签名： <code>EventHandler</code> 委托接受两个参数，第一个参数是事件源，第二个参数是事件参数。例如，<code>public event EventHandler&lt;EventArgs&gt; MyEvent</code>; 定义了一个事件，使用 <code>EventHandler</code> 委托作为事件处理程序的类型。</p>
</li>
<li><p>示例：以下是一个示例，演示了 EventHandler 委托的用法。这里我们定义一个事件并订阅它，使用 EventHandler 委托来处理事件。</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;EventArgs&gt; MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">Example example = <span class="keyword">new</span> Example();</span><br><span class="line">example.MyEvent += (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;事件已触发。&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">example.RaiseEvent();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些系统内置委托类型使编程更加方便，无需手动定义委托类型来处理通用编程任务。它们提供了一种通用的方式来处理不同的场景，包括执行操作、处理事件、测试条件以及处理委托的返回值。</p>
<h3 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h3><p>自定义委托是由开发人员根据应用程序特定的需求创建的委托类型。这些委托具有特定的方法签名，允许定义自己的委托类型，以适应不同的场景。<br>自定义委托是一种自定义的委托类型，它包含以下要素：</p>
<ul>
<li><p>方法签名： 自定义委托具有特定的方法签名，包括返回类型和参数列表。开发人员定义这个方法签名以确保委托可以用于特定的操作。</p>
</li>
<li><p>委托类型名称： 自定义委托需要分配一个类型名称，以便在代码中引用和实例化。</p>
</li>
</ul>
<p>自定义委托通常用于以下情况：</p>
<ul>
<li><p>事件处理： 当您需要处理自定义事件时，可以创建自定义委托类型来表示事件处理程序的方法签名。</p>
</li>
<li><p>特定操作： 当某个方法需要执行特定操作，而这个操作不适合任何现有的系统内置委托类型时，您可以创建自定义委托类型。</p>
</li>
</ul>
<p>以下是一个示例，展示了如何创建和使用自定义委托：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个自定义委托类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CustomDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义委托的使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayGoodbye</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Goodbye, <span class="subst">&#123;name&#125;</span>!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化自定义委托并绑定方法</span></span><br><span class="line">        CustomDelegate helloDelegate = SayHello;</span><br><span class="line">        CustomDelegate goodbyeDelegate = SayGoodbye;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义委托调用方法</span></span><br><span class="line">        helloDelegate(<span class="string">&quot;Ann&quot;</span>); <span class="comment">// 调用 SayHello 方法</span></span><br><span class="line">        goodbyeDelegate(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 调用 SayGoodbye 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：只有签名相同的方法才能注册到委托里</p>
</blockquote>
<p>自定义委托的优点在于，它允许你根据需要定义特定的方法签名，从而在不同的上下文中重用委托，提高代码的灵活性和可维护性。自定义委托也在事件处理和异步编程等方面发挥重要作用，使开发人员能够更好地构建应用程序。</p>
<h2 id="使用委托的要求"><a href="#使用委托的要求" class="headerlink" title="使用委托的要求"></a>使用委托的要求</h2><ul>
<li>定义委托类型：首先要定义委托类型，指定委托可以引用的方法的参数和返回类型。</li>
<li>实例化委托： 委托是引用类型，需要创建委托实例，通常使用委托的构造函数或直接初始化。</li>
<li>调用委托：通过调用委托实例，可以执行它所引用的方法。调用时，传递给方法的参数应与委托的参数列表匹配。</li>
<li>处理空引用：在调用委托之前，需要确保委托不为 null。使用条件运算符（?.）或 null 合并运算符（??）可以帮助处理可能为空的委托。</li>
<li>委托安全性：当使用委托时，需要注意委托的安全性和访问权限。例如，私有方法不可通过公共委托从外部调用。</li>
</ul>
<blockquote>
<p>Tips：<br>在C#中，Invoke 是用于显式调用委托实例所引用的方法的方法。<br>虽然通常我们可以直接调用委托实例（像方法一样使用括号 ()），但在某些情况下，使用 Invoke 方法可以提供更多的控制和可读性。<br>C# 6.0 和更高版本引入了空值条件运算符（null-conditional operator） ?.，它可以与委托的 Invoke 方法一起使用，以避免可能的空引用异常。<br>示例：<br>Action myDelegate &#x3D; () &#x3D;&gt; Console.WriteLine(“这是一个操作。”);<br>myDelegate?.Invoke(); &#x2F;&#x2F; 使用 ?. 运算符来避免可能的空引用异常</p>
</blockquote>
<h2 id="委托的多播"><a href="#委托的多播" class="headerlink" title="委托的多播"></a>委托的多播</h2><p>多播委托是指将多个方法绑定到同一个委托实例上，以便在调用委托时依次执行这些方法。这对于事件处理和回调机制非常有用，因为它可以让多个事件处理程序<strong>同时</strong>响应事件。在注册方法时可以在委托中使用加号运算符或者减号运算符来实现添加或撤销方法。<br>以下是一个多播委托的示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个简单的委托类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SimpleDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个委托实例</span></span><br><span class="line">        SimpleDelegate myDelegate = (message) =&gt; Console.WriteLine(<span class="string">$&quot;第一个处理程序：<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册多个匿名函数</span></span><br><span class="line">        myDelegate += (message) =&gt; Console.WriteLine(<span class="string">$&quot;第二个处理程序：<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        myDelegate += (message) =&gt; Console.WriteLine(<span class="string">$&quot;第三个处理程序：<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用委托，执行多个方法</span></span><br><span class="line">        myDelegate(<span class="string">&quot;这是一个消息。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码会得到结果：<br>第一个处理程序：这是一个消息。<br>第二个处理程序：这是一个消息。<br>第三个处理程序：这是一个消息。</p>
<blockquote>
<p>注意：对于匿名函数，是无法通过对匿名函数本身 -&#x3D; 来取消注册的，因为匿名函数没有引用。如果要取消注册特定的匿名函数，需要使用命名方法而不是匿名函数。</p>
</blockquote>
<p>需要注意的一点是，多播是把添加到委托中的所有目标函数都视为一个整体去执行的，这就导致有两个问题需要注意：</p>
<ul>
<li><p>异常处理：程序在执行这些目标函数的过程中可能发生异常，发生异常之后，异常后面的委托链就不会再执行，这是为了避免潜在的异常蔓延和让程序的行为更可控；</p>
</li>
<li><p>执行结果：程序会把最后执行的那个目标函数所返回的结果当成整个委托的结果。</p>
</li>
</ul>
<p><strong>如何避免踩坑:</strong><br>因为C#把委托链当成了一个对象来执行，所以才有了上述坑。<br>如果你想确保委托链中的每一个方法都被执行，我们可以把委托链拆分成一个列表，只要在该列表上面迭代（foreach），并把这些目标函数轮流执行一遍就可以了。这种方法使您能够更灵活地管理和控制要执行的目标函数，并可以处理每个目标函数的异常情况。以下是一个示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个简单的委托类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SimpleDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FirstMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第一个方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SecondMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第二个方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThirdMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第三个方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 List 来存储目标函数</span></span><br><span class="line">        List&lt;SimpleDelegate&gt; methodList = <span class="keyword">new</span> List&lt;SimpleDelegate&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            FirstMethod,</span><br><span class="line">            SecondMethod,</span><br><span class="line">            ThirdMethod</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个执行 List 中的目标函数</span></span><br><span class="line">        <span class="keyword">foreach</span> (SimpleDelegate method <span class="keyword">in</span> methodList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                method();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;发生异常: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个手动迭代目标函数的方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SimpleDelegate multiDelegate = FirstMethod;</span><br><span class="line">    multiDelegate += SecondMethod;</span><br><span class="line">    multiDelegate += ThirdMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动迭代多播委托的目标函数</span></span><br><span class="line">    <span class="keyword">foreach</span> (SimpleDelegate method <span class="keyword">in</span> multiDelegate.GetInvocationList())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;发生异常: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用委托的好处"><a href="#使用委托的好处" class="headerlink" title="使用委托的好处"></a>使用委托的好处</h2><ul>
<li><p>松耦合和模块化：委托允许将代码模块分离开来，降低了不同部分之间的耦合度。这使得代码更易于理解、维护和扩展。开发者可以在不修改现有代码的情况下添加新的委托实例，以执行不同的操作。</p>
</li>
<li><p>多播委托：委托支持多播，即多个方法可以绑定到同一个委托实例上。这使得事件处理和触发事件时能够调用多个事件处理程序成为可能。多播委托在许多情况下非常有用，如事件系统和回调机制。</p>
</li>
<li><p>回调和异步编程：委托用于回调函数，允许在异步操作完成后执行特定操作。这对于处理异步编程任务非常有用，例如在多线程编程中执行回调操作。</p>
</li>
<li><p>泛型编程：委托允许开发者编写泛型算法，使其适应不同的数据类型和操作。可以将不同的委托传递给算法，以实现不同的功能。</p>
</li>
<li><p>动态方法调用：委托允许在运行时动态地选择要调用的方法。这对于插件系统和动态代码生成非常有用，因为可以在运行时根据需求选择要执行的代码。</p>
</li>
<li><p>事件处理：委托是事件处理的核心，使你能够订阅和取消订阅事件，以便在事件发生时执行特定操作。这在GUI应用程序和Web应用程序中非常常见。</p>
</li>
<li><p>可测试性：委托允许将依赖注入（Dependency Injection）和模拟（Mocking）引入应用程序，以便更轻松地进行单元测试。开发者可以模拟委托以测试代码的不同路径和情况。</p>
</li>
<li><p>灵活性：委托使代码更加灵活，可以根据需要执行不同的操作。这提供了一种通用的方式来处理各种编程任务，而无需编写大量的重复代码。</p>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>委托大致说完了，我们再来简单了解一下事件吧~<br>在C#中，事件是一种用于实现观察者模式的重要机制，用于处理对象之间的通信和交互。事件允许一个对象（称为<strong>事件源</strong>）通知其他对象（称为<strong>事件处理程序</strong>）发生了特定的情况，以便事件处理程序能够采取适当的行动。事件和委托是密切相关的。</p>
<ul>
<li><p>事件定义：在C#中，事件的定义通常包括两个主要元素：事件声明和事件处理程序（委托）。以下是一个事件的基本定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 MyEvent 的事件，它使用 EventHandler 委托作为事件处理程序的类型。事件通常声明为 public，以便其他类能够订阅它。</p>
</li>
<li><p>订阅事件：其他类可以订阅事件，以便在事件发生时执行特定的操作。事件处理程序是一个方法，其签名与事件声明中指定的委托类型相匹配。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventSubscriber</span>(<span class="params">EventPublisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理程序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;事件已发生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发事件：事件源使用事件触发方法来通知事件处理程序事件已发生。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件参数：通常，事件处理程序需要访问有关事件的信息。为此，事件参数类通常派生自 EventArgs 类，可以包含事件相关的任何信息。事件处理程序可以从事件参数对象中获取这些信息。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> EventInfo &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEventArgs</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EventInfo = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消订阅事件：在不再需要订阅事件的情况下，可以取消订阅以释放资源和避免不必要的事件通知。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventSubscriber</span>(<span class="params">EventPublisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅事件</span></span><br><span class="line">        publisher.MyEvent -= HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理程序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;事件已发生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>委托和事件都在C#中具有重要意义，它们有助于实现松散耦合的、模块化的代码，提高代码的可维护性和可扩展性，同时允许实现各种设计模式和编程范例，所以了解委托和事件很重要。<br>在最后，让我们用委托的方式来实现一下开头的需求吧！<br>首先，定义一个提醒音乐委托类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public delegate void AlarmSound();</span><br></pre></td></tr></table></figure>

<p>然后，修改AlarmClock类以接受委托作为参数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AlarmClock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAlarm</span>(<span class="params">AlarmSound alarm</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置提醒音乐</span></span><br><span class="line">        alarm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，可以使用一个通用的SetAlarm方法，将不同的提醒音乐表示为委托：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">AlarmClock clock = <span class="keyword">new</span> AlarmClock();</span><br><span class="line"></span><br><span class="line">AlarmSound workAlarm = () =&gt; &#123; <span class="comment">/* 设置工作提醒音乐的操作 */</span> &#125;;</span><br><span class="line">AlarmSound exerciseAlarm = () =&gt; &#123; <span class="comment">/* 设置锻炼提醒音乐的操作 */</span> &#125;;</span><br><span class="line"></span><br><span class="line">clock.SetAlarm(workAlarm);</span><br><span class="line">clock.SetAlarm(exerciseAlarm);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的三大特点</title>
    <url>/2023/10/23/CSharp/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<p>C#是一种面向对象的编程语言，广泛用于开发各类应用程序。同时，C#作为一种多范式语言，也支持面向过程编程。面向对象的特点我们耳熟能详，但新手可能会说不清楚，为什么要这样设计。今天我们就对面向对象的三大核心特点：封装，继承，多态来进行超详细讲解。</p>
<span id="more"></span>
<blockquote>
<p><strong>面向对象编程</strong>是一种以对象为中心的编程范式，它将数据和操作数据的方法组合成对象。在面向对象编程中，程序被组织成一组相互作用的对象，这些对象通过彼此发送消息来传递数据。<br><strong>面向过程编程</strong>是一种以过程为中心的编程范式，它主要关注解决问题时所需要执行的步骤。在面向过程编程中，程序被组织成一系列的函数或方法，这些函数或方法按照特定的顺序被调用来完成任务。</p>
</blockquote>
<h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BankAccountWithoutEncapsulation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Balance; <span class="comment">// 公开的余额字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deposit</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Withdraw</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举一个简单的小例子，假设一种场景，有一个银行账户类，包括余额和存取款方法等。如果直接将余额设为public，其他类能直接从外部访问账户类的余额信息，这种设计存在一些问题：</p>
<ul>
<li>数据不受限制：外部代码可以随意修改Balance字段，而没有任何限制，这可能导致不合法的操作，如负数余额。</li>
<li>无法实施验证：无法在存款或取款方法中实施验证，以确保金额不为负数或其他不合法值。</li>
<li>缺乏安全性：敏感的账户余额可以在外部被直接访问，而不受任何控制。</li>
</ul>
<p>这种设计明显是不合理的，那么应该怎样修改呢？我们可以试着将Balance声明为private，添加一个public方法来访问Balance，外部代码无法直接访问它，而必须使用公共方法来与余额进行交互，这样就解决了上述问题。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BankAccountWithEncapsulation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">decimal</span> balance; <span class="comment">// 私有的余额字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">decimal</span> <span class="title">GetBalance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> balance; <span class="comment">// 通过公共方法返回余额</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deposit</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Withdraw</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; balance &gt;= amount)</span><br><span class="line">        &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的运用了封装的例子，体现了封装的数据隐藏和安全性。<br>那么具体什么是封装呢？封装其实就是一种将数据（属性）和操作数据的方法（方法）组合成一个单元，并且把这些内部细节隐藏起来，只暴露必要的公共接口供其他对象访问的机制。封装的主要目标是隔离对象的内部实现，以提高代码的可维护性、安全性和可重用性。封装的关键概念包括：</p>
<ul>
<li><p>数据隐藏：封装将对象的数据（通常是字段或属性）设为私有或受限访问，使其不能直接被外部对象访问，从而防止外部对象直接修改或破坏对象的内部状态。</p>
</li>
<li><p>公共接口：封装通过提供公共方法或属性，允许其他对象与封装对象进行交互。这些公共接口定义了外部对象可以如何与对象互动，并提供了访问对象数据和执行对象操作的途径。</p>
</li>
<li><p>数据验证和保护：通过封装，可以在公共接口中添加数据验证逻辑，以确保数据的合法性，防止不合法的访问和修改。</p>
</li>
<li><p>隐藏实现细节：封装允许对象内部的实现细节保持私有，外部对象不需要了解对象的内部工作原理，只需要知道如何与对象互动。</p>
</li>
<li><p>安全性：封装提高了数据的安全性，因为外部对象无法直接访问和修改对象的私有数据。</p>
</li>
</ul>
<p>通过封装，面向对象编程能够将复杂性管理在对象内部，提供了清晰、简化的公共接口，使代码更易于理解、维护和扩展，有助于构建模块化、可靠和可维护的应用程序。</p>
<h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><p>继续假设这样一个场景，我们想做一个动物管理系统，涉及到很多个动物种类，假如直接为每一种动物都写一个类，那么每一个类都要包含名称，种类，科属等字段，并且每一个类都会有一些相同的方法，例如吃饭，休息等。这样写下来代码就会有非常大的重复和冗余。那么该怎样改进呢？<br>我们可以将这些动物的共同属性和方法提取出来，放在一个类中，提供一个基础的框架，以定义动物的基本属性和行为。在这个框架的基础上，每个动物类都可以添加自己独有的属性和方法，例如”Cat”类可以添加属性”毛色”和方法”捉老鼠”，”Bird”类可以添加属性”翅膀长度”和方法”飞翔”。<br>这就是继承的思想。这个被提取出来的公共类就叫做基类，在这个框架的基础上进行拓展的类就叫做派生类。继承允许我们构建层次化结构，其中基类定义了共享特征，而派生类继承这些特征并添加特定于自身的内容，从而实现了代码重用和抽象化，这有助于更清晰地表示现实世界中的关系和层次结构。继承的好处非常多，例如：</p>
<ul>
<li>代码重用：继承允许子类（派生类）继承父类（基类）的属性和方法，从而避免了重复编写相同的代码。这促进了代码的重用，减少了代码冗余。</li>
<li>抽象化和通用性：基类可以定义通用的属性和方法，捕获多个子类之间共享的特性。这种抽象化有助于更好地建模现实世界的关系，并提供通用性。</li>
<li>层次化组织：继承允许创建层次结构，通过将相关的类组织在一起，更清晰地表示它们之间的关系。这有助于代码的结构和理解。</li>
<li>可扩展性：新的子类可以轻松地添加到继承层次结构中，而无需修改现有的代码。这提高了应用程序的可扩展性，使其能够适应新的需求。</li>
<li>维护性：继承有助于代码的维护，因为通用代码只需在一个地方维护，而不需要在每个子类中进行修改。这降低了维护的成本。<br>-多态性：继承是多态性的基础。多态性允许不同的子类对象对相同的方法进行不同的实现，从而提高了代码的灵活性和可扩展性。</li>
<li>封装实现细节：基类可以封装实现细节，隐藏其内部工作原理，允许子类专注于其独特的功能。</li>
<li>重用已有类：继承允许在现有类的基础上构建新的类，以便重用已有类的功能，并添加新的功能。</li>
</ul>
<p>总之，继承是面向对象编程中的重要概念，它提供了许多好处，包括代码重用、抽象化、层次化组织、可扩展性、维护性和灵活性，这使得继承成为构建复杂应用程序的强大工具。</p>
<blockquote>
<p>继承的传递性：传递机制 a-&gt;b，b-&gt;c，c具有a的特性。<br>继承的单根性：在C#中一个类只能继承一个父类，不能有多个父类。</p>
</blockquote>
<h2 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>多态是个比较抽象的概念，我们可以继续通过一个小例子来理解多态的概念。回合制游戏中，往往有这样一种场景：场上有一组不同类型的怪物，例如巨魔，巫师，恶龙，怪物依次对玩家进行攻击。假设没有继承和多态，需要为每种类型的怪物都设置一个列表，巨魔列表，恶龙列表，狼人列表，依次遍历所有列表，调用对应怪物类的Attack方法来对玩家进行攻击。<br>再有了继承的概念之后，我们可以将所有怪物的共同属性和方法提取出来，变成一个Monster基类，不同怪物类都可以继承Monster类，这样就只需要一个<code>List&lt;Monster&gt;</code>就能管理所有怪物，不需要多个列表。<br>但这样依然会有一个问题，在遍历这个列表的过程中，我们需要依次判断列表元素对应的怪物种类是什么，然后再执行对应怪物子类的攻击方法，这样做依然很不方便，需要大量的switch和if语句，这时候，就引入了多态的概念。<br>多态是什么呢？多态顾名思义，就是<strong>对象的多种状态</strong>。它表示在不同的对象上可以执行相同的操作，但这些操作可以根据对象的实际类型而具有不同的行为。多态性的核心思想是：在同一个方法或属性被不同类的对象调用时，可以根据对象的实际类型来执行不同的操作。<br>多态性有两种主要形式：</p>
<ul>
<li>编译时多态性（静态多态性）：这是方法的重载和方法的重写，它们在编译时确定方法调用的方式。方法的重载是指在同一个类中有多个方法，但它们具有相同的名称，但不同的参数列表。方法的重写是指派生类可以覆盖基类中的方法，以提供自己的实现。</li>
<li>运行时多态性（动态多态性）：这是多态性的经典形式，它允许在运行时根据对象的实际类型来确定方法调用的方式。这通常涉及到继承和方法覆盖。在运行时，基于对象的实际类型，可以调用适当的方法实现。</li>
</ul>
<p>落到这个例子上，多态是如何实现的呢？首先我们定义一个Moster基类，包含一个virtual修饰的Attack方法，其他怪物子类继承这个基类，在子类中重写（覆盖）这个Attack方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;怪物攻击了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Troll</span> : <span class="title">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;巨魔挥舞着大棒攻击！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Wizard</span> : <span class="title">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;巫师发射了火球攻击！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dragon</span> : <span class="title">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;恶龙喷射火焰攻击！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设场上的怪物都用<code>List&lt;Monster&gt; monsters</code>来存储，我们遍历这个列表，调用Attack方法时，根据每个怪物的实际类型，会自动执行对应的攻击方式。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Monster monster <span class="keyword">in</span> monsters)</span><br><span class="line">&#123;</span><br><span class="line">    monster.Attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态性的优势在于可以将不同类型的对象当作通用的基类对象处理，从而提高代码的可重用性、可维护性和可扩展性。多态性使代码更具灵活性，能够处理不同情况下的相同方法调用，从而更好地模拟现实世界的复杂性。<br>多态的优点主要有：</p>
<ul>
<li>提高代码的灵活性和通用性：多态性允许将不同类型的对象视为其共同的基类对象，从而编写通用代码，可以处理多种不同类型的对象。这提高了代码的通用性和灵活性。</li>
<li>简化代码：使用多态性可以减少重复的代码，因为可以将通用的操作应用于多个对象，而不需要为每个对象编写特定的操作。</li>
<li>支持动态绑定：多态性允许在运行时动态地选择要调用的方法，而不需要在编译时知道对象的具体类型。这提供了更大的灵活性，适应不同的运行时条件。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，封装、继承和多态性有助于构建更安全、可维护、可扩展和通用的软件系统。它们提供了一种有效的方式来管理复杂性，降低代码的复杂性，从而更好地满足现实世界问题的需求。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC、MVP、MVVM架构</title>
    <url>/2023/11/05/Unity/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>试想一下这种场景：初学者想做一个简单的小游戏，由于没有做任何代码结构的分层，可能会将游戏逻辑、角色属性和 ui 交互都混在一起编写。当我们需要增加或修改任何功能或界面时，牵一发而动全身，可能会需要修改整个脚本，容易出现错误和影响其他功能，代码阅读也会更加困难。为了解决这些问题，可以采用一些合适的软件架构模式，以更好地组织和管理游戏代码。今天我们就来了解几个常见的软件架构模式。</p>
<span id="more"></span>
<h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><h3 id="MVC架构简介"><a href="#MVC架构简介" class="headerlink" title="MVC架构简介"></a>MVC架构简介</h3><p>MVC（Model-View-Controller）是一种经典的软件架构模式，广泛用于各种应用程序，包括游戏开发。MVC将应用程序分成三个主要部分，每个部分有不同的责任，以实现代码的分离和可维护性。这三个组成部分分别是：</p>
<ul>
<li><p><strong>Model（模型）</strong> ：</p>
<ul>
<li>模型表示应用程序的数据和业务逻辑，是应用程序的核心。</li>
<li>它负责数据的存储、处理和更新，以及对外提供数据的访问接口。</li>
<li>模型通常不直接处理视图和用户输入，是独立的数据层。</li>
<li>在游戏中，Model可以表示游戏中的角色、物体、游戏规则、关卡数据等。</li>
</ul>
</li>
<li><p><strong>View（视图）</strong> ：</p>
<ul>
<li>View代表用户界面，是模型的可视化表示。</li>
<li>视图负责呈现数据给用户并接受用户输入。</li>
<li>视图不包含应用程序的业务逻辑，仅负责显示数据，它从模型中获取数据，并将其呈现在屏幕上。</li>
<li>视图是被动的，它不直接处理用户输入，而是将输入传递给控制器进行处理。</li>
<li>在游戏中，View可以是游戏中的UI元素、画面渲染等。</li>
</ul>
</li>
<li><p><strong>Controller（控制器）</strong> ：</p>
<ul>
<li>控制器是应用程序中的决策者，充当了模型和视图之间的中介。</li>
<li>控制器负责处理用户的输入，并根据输入更新模型和视图，协调Model和View之间的交互。</li>
<li>在游戏中，Controller可以处理玩家的输入、游戏规则的执行等。</li>
</ul>
</li>
</ul>
<h3 id="MVC工作流程"><a href="#MVC工作流程" class="headerlink" title="MVC工作流程"></a>MVC工作流程</h3><p>MVC模式的工作流程通常如下：<br><img src="/../../images/pic7/MVC.png" alt="MVC"></p>
<ul>
<li>用户与View进行交互，例如，点击按钮或输入文本，这些操作触发了View中的相关事件。</li>
<li>View感知到这些事件后，通常通过事件处理程序或回调机制通知Controller进行处理。</li>
<li>Controller接收到View传递的事件后，开始处理相关业务逻辑，根据用户的操作更新Model中的数据或调用Model中的业务逻辑。</li>
<li>Model的业务数据改变触发相应事件，通知View业务数据已经发生改变。</li>
<li>View捕获到Model发出的数据改变事件，重新获取数据并更新用户界面。</li>
</ul>
<h3 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h3><ul>
<li><strong>代码分离</strong> ：MVC将应用程序分成三个独立的组件（模型、视图和控制器），每个组件都有自己的责任和功能。这样可以实现分离关注点，让代码模块更清晰、结构更合理，提高代码的可读性和可维护性。</li>
<li><strong>代码重用</strong> ：由于MVC的分离性，不同部分的代码可以更容易地进行重用。模型和视图可以在不同场景或不同应用中重用，而控制器可以处理不同的用户输入，从而减少了重复编写代码的情况。</li>
<li><strong>可维护性</strong> ：由于模块化的设计，可以更容易定位和修复问题，以及进行功能扩展。</li>
<li><strong>可扩展性</strong> ：MVC的分层结构使得应用程序更易于扩展。添加新的功能或模块时，可以通过增加模型、视图或控制器来实现，而不需要修改整个应用程序的代码。</li>
<li><strong>团队协作</strong> ：MVC将应用程序拆分成三个部分，使得不同的团队成员可以独立地并行开发和测试各自的组件。这样有利于团队协作，提高项目的开发效率。</li>
<li><strong>易于测试</strong> ：MVC架构使得应用程序的不同部分可以更容易地进行单元测试。因为模型、视图和控制器的职责分离，测试可以更加集中和专注。</li>
</ul>
<h3 id="Unity项目中的MVC思想"><a href="#Unity项目中的MVC思想" class="headerlink" title="Unity项目中的MVC思想"></a>Unity项目中的MVC思想</h3><p><strong>注意，Unity项目开发中的MVC可能并不是严格的传统MVC模式，而是一种变种或简化的方式，因为游戏开发不像网站开发那样，Model，View，Controller在游戏这个领域里还没有很清晰的定义，不同游戏类型本身的软件架构可以相差很远，而且游戏的Object之间有大量的交互，所以纯粹的MVC并不适用，我们这里讲的主要是一种逻辑分离的思想，具体运用需要根据项目的需求和复杂性进行调整。</strong></p>
<p>在Unity开发中，MVC思想可以用于分离游戏的数据、用户界面和控制逻辑，以提高代码的可维护性和可读性。</p>
<ul>
<li><strong>Model（模型）</strong> ：在Unity中，模型可以是代表游戏中的各种数据和业务逻辑的脚本类。例如，角色属性、游戏状态、游戏规则、关卡数据、道具等数据和逻辑都可以被归类为模型。使用C#类来定义Model，这些类包含数据成员和方法来操作数据，但不包括Unity的MonoBehaviour。</li>
<li><strong>View（视图）</strong> ：在Unity中，视图可以是代表游戏场景中的物体、UI元素或预制件，用于展示模型中的数据。Unity中的Canvas、UI元素、3D模型等可以作为View的一部分。View负责将Model的数据呈现给用户，并将用户输入传递给Controller。</li>
<li><strong>Controller（控制器）</strong> ：在Unity中，控制器可以是脚本类，负责处理用户的输入，并根据输入来更新模型和视图，协调Model和View之间的交互，实施游戏逻辑。Controller可以处理用户输入，如鼠标点击、键盘输入等，然后更新Model中的数据或调用Model中的方法来执行游戏逻辑。它还可以更新View以反映Model的变化。</li>
</ul>
<p>此外，可以使用事件系统或委托来实现Model、View和Controller之间的通信。事件可以用于通知不同部分之间的状态变化，例如，当玩家得分时，Controller可以触发一个事件，View可以订阅该事件以更新分数显示。</p>
<p>在Unity项目中采用MVC思想可以带来一些好处：</p>
<ul>
<li><strong>代码组织</strong> ：Unity项目通常会变得复杂，特别是在游戏开发中，有大量的游戏对象、脚本和交互逻辑。采用MVC思想可以帮助更好地组织代码，将模型、视图和控制器分离开来，使得代码结构更清晰，易于阅读和维护。</li>
<li><strong>可维护性</strong> ：MVC的分层结构使得修改和扩展游戏功能变得更加容易。如果需要更改游戏逻辑或UI展示，只需要关注对应的控制器或视图，而不需要影响整个游戏代码。</li>
<li><strong>UI管理</strong> ：在Unity中，UI通常是一个重要的部分，MVC思想可以帮助将UI和逻辑分离开来。通过采用MVC，我们可以更好地管理UI的展示和交互逻辑。当需要添加新功能或修改UI显示时，只需修改对应的模型、视图或控制器类，不会影响其他部分的代码。</li>
<li><strong>数据共享</strong> ：在Unity中，MVC可以帮助我们实现数据的共享和重用。通过将数据逻辑放在模型中，并在不同的场景或游戏对象中共享模型，可以使得数据在整个游戏中保持一致性。</li>
<li><strong>耦合性低</strong> ：角色的数据和行为被封装在模型中，视图和控制器只负责显示和交互，降低了代码耦合度，增加了代码复用性和扩展性。</li>
</ul>
<p>总的来说，MVC思想在Unity项目中可以提供更好的代码组织、可维护性和扩展性，使得项目开发更加高效和有条理。但要根据项目的规模和需求来选择是否采用MVC，对于小型项目可能并不需要过度划分MVC架构，而在大型或复杂项目中，采用MVC可以带来更多的好处。</p>
<h2 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h2><h3 id="MVP架构简介"><a href="#MVP架构简介" class="headerlink" title="MVP架构简介"></a>MVP架构简介</h3><p>MVP（Model-View-Presenter）是从MVC演变而来的一种架构模式。在MVC的基础上，MVP强调Model与View之间的隔离，两者互不感知。MVP模式的主要组成部分如下：</p>
<ul>
<li><strong>Model（模型）</strong> ：<ul>
<li>Model代表应用程序的数据和业务逻辑。</li>
<li>Model包含数据的存储、检索、更新和应用程序的核心业务逻辑。</li>
<li>Model不直接与用户界面交互，通常是一个独立的数据层。</li>
</ul>
</li>
<li><strong>View（视图）</strong> ：<ul>
<li>View负责呈现数据给用户，并接受用户输入。</li>
<li>View通常包括用户界面元素，如窗口、按钮、文本框等。</li>
<li>View是用户界面的可视表示，但不包含与数据处理或业务逻辑相关的代码。</li>
</ul>
</li>
<li><strong>Presenter（主持人）</strong> ：<ul>
<li>Presenter充当Model和View之间的中介，负责协调用户界面逻辑，将Model的数据呈现给View，并处理用户输入。</li>
<li>Presenter包括以下方面的工作：<ul>
<li>从Model检索数据并准备数据以便呈现在View上。</li>
<li>接受用户输入并将其传递给Model以执行相应的操作。</li>
<li>处理用户界面逻辑，例如数据格式验证、格式转换、用户输入提示等。</li>
</ul>
</li>
<li>Presenter不应包含任何与用户界面视觉表示相关的代码。</li>
</ul>
</li>
</ul>
<h3 id="MVP工作流程"><a href="#MVP工作流程" class="headerlink" title="MVP工作流程"></a>MVP工作流程</h3><p>MVP模式的工作流程通常如下：<br><img src="/../../images/pic7/MVP.jpg" alt="MVP"></p>
<ul>
<li>用户对界面进行操作，例如点击按钮或输入文本，触发View的相关事件。</li>
<li>View感知到这些事件之后，通过特定的接口或回调方法，通知Presenter进行处理。这是View与Presenter之间的通信。</li>
<li>Presenter接收到来自View的事件通知后，开始处理业务逻辑。这可能涉及从Model中检索数据、执行特定操作，验证数据，或进行其他业务相关的任务。</li>
<li>如果Presenter需要更新数据，它将通过Model的接口来对数据进行更新或请求必要的数据。</li>
<li>当Model中的数据发生变化时，Model会通知Presenter，通常通过观察者模式或其他通知机制。</li>
<li>Presenter收到Model数据变化通知后，调用View暴露的接口更新用户界面，使用户能够看到数据的变化。</li>
</ul>
<h3 id="MVP的优点"><a href="#MVP的优点" class="headerlink" title="MVP的优点"></a>MVP的优点</h3><p>MVP模式具备MVC模式的优点，且相比于传统的MVC模式引入了一些额外的优点：</p>
<ul>
<li><strong>松耦合度的增加</strong> ：在MVP中，View和Model之间不直接通信，而是通过Presenter进行协调。这降低了View和Model之间的耦合度，使它们可以独立开发和维护。这使得更容易替换View或Model，而不会影响整个应用程序的结构。</li>
<li><strong>更好的分离关注点</strong> ：MVC常常会因为V和M的耦合性太强而渐渐产生问题，导致C渐渐失去作用，但MVP模式视图和模型完全分离。</li>
<li><strong>更容易实现多视图</strong> ：MVP模式使得更容易实现多个不同的视图，共享相同的Presenter。这可以在不重复编写业务逻辑的情况下创建多个用户界面，从而提高了代码的复用性。</li>
<li><strong>逻辑的集中管理</strong> ：在MVP中，Presenter充当了中央控制器，负责管理用户界面逻辑和业务逻辑。这样，所有与用户界面相关的逻辑都集中在一个地方，而不分散在控制器和视图之间。这有助于更好地组织代码和降低复杂性。</li>
<li><strong>提高用户界面的可定制性</strong> ：由于MVP模式将用户界面和业务逻辑分开，更容易调整和自定义用户界面的外观和行为，而不需要修改底层逻辑。</li>
<li><strong>Model设计更灵活</strong> ：所有交互都在P中实现，M的设计可以更加灵活，有利于M的高效使用。</li>
</ul>
<h2 id="MVVM架构"><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h2><h3 id="MVVM架构简介"><a href="#MVVM架构简介" class="headerlink" title="MVVM架构简介"></a>MVVM架构简介</h3><p>MVVM（Model-View-ViewModel）也是MVC的演变而来，通常用于构建用户界面（UI）驱动的应用程序。它在传统的MVC模式基础上将Controller层变成了ViewModel层，MVVM代表Model-View-ViewModel。MVVM强调数据绑定，从而省去了模型数据改变后通知数据更新的步骤。MVVM模式由以下三个主要组成部分组成：</p>
<ul>
<li><strong>Model（模型）</strong> ：<ul>
<li>Model代表应用程序的数据和业务逻辑。</li>
<li>Model包含数据和方法，用于处理数据的存储、检索、更新和应用程序的核心业务逻辑。</li>
<li>Model通常不直接与用户界面交互，而是为ViewModel提供数据。</li>
</ul>
</li>
<li><strong>View（视图）</strong> ：<ul>
<li>View负责呈现数据给用户并接受用户输入。</li>
<li>View通常包括用户界面元素，如窗口、按钮、文本框等。</li>
<li>View通过数据绑定将自己与ViewModel连接，ViewModel可以提供数据和逻辑，以便View进行呈现。</li>
</ul>
</li>
<li><strong>ViewModel（视图模型）</strong> ：<ul>
<li>ViewModel充当Model和View之间的中介，负责处理用户界面逻辑，将Model的数据呈现给View，并处理用户输入。</li>
<li>ViewModel包括以下方面的工作：<ul>
<li>数据绑定：ViewModel提供要在View中显示的数据，并与View建立数据绑定。这样，当Model中的数据更改时，View会自动更新。</li>
<li>命令处理：ViewModel包含命令，例如按钮点击事件，以执行与用户交互相关的操作。</li>
<li>数据验证：ViewModel可以包括验证逻辑，以确保用户输入的有效性。</li>
<li>与Model的交互：ViewModel与Model交互，检索、更新或操作数据。</li>
<li>处理用户输入：ViewModel接受用户输入，执行相应的操作，例如更新Model中的数据或触发特定的命令。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MVVM工作流程"><a href="#MVVM工作流程" class="headerlink" title="MVVM工作流程"></a>MVVM工作流程</h3><p>MVVM模式的工作流程通常如下：<br><img src="/../../images/pic7/MVVM.jpg" alt="MVVM"></p>
<ul>
<li>界面渲染完毕后，ViewModel会将View和Model按照开发时声明的方式进行双向绑定。</li>
<li>用户对界面进行操作，触发View中的相关事件。</li>
<li>View接收用户输入，并将其传递给ViewModel。</li>
<li>ViewModel调用Model的接口处理业务逻辑。</li>
<li>Model数据发生变化后，通知ViewModel，View通过数据绑定<strong>自动</strong>将更新后的数据呈现给用户，以反映最新的数据状态。所以Model内容改变后，用户界面会立即更新，无需额外操作。</li>
</ul>
<h3 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h3><p>MVVM相对于传统的MVC和MVP模式又具有一些额外的优点，例如：</p>
<ul>
<li><strong>自动数据绑定</strong> ：MVVM借助数据绑定机制，实现了视图与视图模型之间的双向数据绑定。这使得用户界面元素能够自动更新以反映视图模型中的数据变化，而不需要编写手动的更新逻辑。这提高了代码的简洁性和可维护性。</li>
<li><strong>适应现代UI</strong> ：MVVM适用于现代的用户界面开发，包括Web应用、桌面应用和移动应用。其自动数据绑定和响应式特性使其非常适合创建交互性强、实时性要求高的应用程序。</li>
<li><strong>多平台通用性</strong> ：MVVM模式适用于不同平台的应用程序开发，因为其核心概念是通用的。这允许开发人员在不同平台上使用相似的架构模式。</li>
</ul>
<h2 id="对比MVC、MVP、MVVM"><a href="#对比MVC、MVP、MVVM" class="headerlink" title="对比MVC、MVP、MVVM"></a>对比MVC、MVP、MVVM</h2><p>从上面对MVC、MVP、MVVM的介绍可以明显地看出，它们呈现递进关系，是不断优化的软件架构模式。MVP在MVC的基础上实现了M和V的解耦，MVVM在MVP的基础上实现了数据绑定。它们在不同方面具有不同的优劣势，我们可以简单进行一下三者的总结和对比。</p>
<h3 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h3><h4 id="MVC优点"><a href="#MVC优点" class="headerlink" title="MVC优点"></a>MVC优点</h4><ul>
<li><strong>广泛使用</strong> ：MVC是一种经典且广泛使用的架构模式，开发者们对MVC非常熟悉，它在许多传统的Web和桌面应用中得到了广泛应用。</li>
<li><strong>分离关注点</strong> ：MVC将应用程序分成三个独立的组件，分别负责数据处理、界面展示和用户输入处理，使代码更易于理解和维护。</li>
<li><strong>代码复用</strong> ：由于MVC的分离性，不同部分的代码可以更容易地进行重用，使得开发效率提高。</li>
<li><strong>成熟的生态系统</strong> ：MVC有丰富的工具和框架支持，如Django、Ruby on Rails、Spring等。</li>
</ul>
<h4 id="MVC缺点"><a href="#MVC缺点" class="headerlink" title="MVC缺点"></a>MVC缺点</h4><ul>
<li><strong>耦合度较高</strong> ：在MVC中，View和Controller之间通常是紧耦合的，Controller直接处理View的事件，这样可能导致代码依赖性较高。且MVC并未限制数据流，Model和View可能有耦合。</li>
<li><strong>Controller负担较重</strong> ：在MVC中，Controller承担了大部分的用户输入处理和业务逻辑，随着应用复杂度的增加，Controller可能会变得庞大和复杂。</li>
</ul>
<h4 id="MVC适用场景和示例"><a href="#MVC适用场景和示例" class="headerlink" title="MVC适用场景和示例"></a>MVC适用场景和示例</h4><ul>
<li>Web应用：MVC是Web应用中最常见的架构模式，例如ASP.NET MVC框架。</li>
<li>桌面应用：传统的桌面应用程序，如使用Java Swing或Windows Forms等，也可以采用MVC模式。</li>
<li>MVC在Unity中通常用于较为简单的项目或小型游戏，特别是当项目的UI和逻辑较为简单，或者开发者对MVC较为熟悉时。</li>
<li>在Unity中，MVC模式可以通过自定义脚本组件来实现。模型通常代表游戏中的数据和业务逻辑，视图负责展示数据给用户，控制器处理用户输入并更新模型和视图。</li>
</ul>
<h3 id="MVP的优缺点"><a href="#MVP的优缺点" class="headerlink" title="MVP的优缺点"></a>MVP的优缺点</h3><h4 id="MVP优点"><a href="#MVP优点" class="headerlink" title="MVP优点"></a>MVP优点</h4><ul>
<li><strong>更强的分离</strong> ：相较于MVC，MVP通过引入Presenter，进一步增强了模型、视图和控制器之间的分离，使每个部分更加独立。</li>
<li><strong>可测试性</strong> ：Presenter是业务逻辑的中心，易于进行单元测试，有助于提高代码质量。</li>
<li><strong>框架不依赖</strong> ：MVP模式不依赖具体的框架，适用于不同的开发环境。</li>
</ul>
<h4 id="MVP缺点"><a href="#MVP缺点" class="headerlink" title="MVP缺点"></a>MVP缺点</h4><ul>
<li><strong>代码量增加</strong> ：引入Presenter可能导致代码量增加，但这有助于更好的分离关注点。</li>
<li><strong>较少的自动化</strong> ：相对于MVVM，MVP通常需要更多手动的工作来更新视图，因为没有自动数据绑定机制。</li>
</ul>
<h4 id="MVP适用场景和示例"><a href="#MVP适用场景和示例" class="headerlink" title="MVP适用场景和示例"></a>MVP适用场景和示例</h4><ul>
<li>适用于桌面应用程序、一些前端框架和具有较强用户交互的应用。</li>
<li>用于需要更好的分离关注点和可测试性的应用，其中模型负责数据和业务逻辑，视图负责用户界面，主持人负责处理用户输入和协调模型和视图之间的通信。</li>
</ul>
<h3 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h3><h4 id="MVVM优点"><a href="#MVVM优点" class="headerlink" title="MVVM优点"></a>MVVM优点</h4><ul>
<li><strong>强大的数据绑定</strong> ：相较于MVP，MVVM引入了自动数据绑定，使视图与视图模型之间的数据同步自动完成，简化了用户界面的更新。</li>
<li><strong>更好的分离</strong> ：相较于MVC，MVVM将模型、视图和视图模型更清晰地分离，降低了耦合度。</li>
<li><strong>适应现代UI</strong> ：MVVM非常适用于需要响应性和实时性的应用程序，如单页应用程序（SPA）和移动应用。</li>
</ul>
<h4 id="MVVM缺点"><a href="#MVVM缺点" class="headerlink" title="MVVM缺点"></a>MVVM缺点</h4><ul>
<li><strong>学习曲线</strong> ：相对于MVC和MVP，MVVM的学习曲线可能较陡，尤其是对于初学者来说，掌握数据绑定和ViewModel的概念可能需要一些时间。</li>
<li><strong>不适合所有场景</strong> ：MVVM更适合复杂的用户界面和需要实时数据更新的应用程序，但对于简单的应用程序可能显得过于繁琐。</li>
</ul>
<h4 id="MVVM适用场景和示例"><a href="#MVVM适用场景和示例" class="headerlink" title="MVVM适用场景和示例"></a>MVVM适用场景和示例</h4><ul>
<li>响应式UI：MVVM特别适用于需要响应式UI的项目，例如使用WPF或Vue.js等前端框架。当UI与数据交互较为复杂，或者需要实现数据驱动的UI时，MVVM是一种较好的选择。</li>
<li>数据驱动应用：当应用的主要逻辑是数据驱动时，MVVM可以更好地组织和管理数据和界面的交互。</li>
<li>复杂的前端应用：对于大型、复杂的前端应用，MVVM能够帮助开发者更好地管理代码，并保持UI和数据的同步。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVC适用于传统的Web和桌面应用，MVP适用于分离性要求更高的Web和桌面应用，MVVM适用于响应式UI和数据驱动的应用。在Unity项目开发中，选择使用MVC、MVP还是MVVM取决于项目的需求和复杂性。对于较为简单的项目或小型游戏，MVC或MVP可能足够满足需求。而对于复杂的项目或需要响应式UI的场景，MVVM提供了更好的代码组织和管理方式，使得UI和数据的交互更加清晰和灵活。在选择使用哪种架构模式时，要根据项目的需求和复杂性来进行考虑，并结合团队成员的熟悉程度和技术栈来决定使用何种模式。在实际项目中，也可以根据需求的变化来灵活选择和调整架构模式。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity协程详解</title>
    <url>/2023/10/26/Unity/Unity%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>协程（Coroutine）是一种用于异步编程的概念和技术，它允许程序在执行任务的过程中暂停，然后在稍后的时间继续执行，而不会阻塞整个应用程序或线程。协程在游戏开发、图形编程和事件驱动的应用程序中非常有用，因为它们可以处理需要等待、延迟执行、动画效果、网络请求等情况，同时保持应用的响应性和性能。</p>
<span id="more"></span>
<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>在 unity 中，我们一般不考虑多线程，因为 Unity 只能在主线程中获取物体的组件、方法、对象等，脱离了这些功能，多线程的意义就不大了。但当主线程在执行一个对资源消耗很大的操作时，如果在一帧中实现这些操作，游戏就会变得十分卡顿，这个时候，我们就可以通过协程，在<strong>多帧</strong>内完成该工作的处理，同时不影响主任务的进行。所以协程顾名思义，就是辅助主线程的协助程序，用来执行一些资源消耗大的脏活累活，避免主线程卡顿。需要明确<strong>协程不是线程，协程依旧是在主线程中进行的</strong>。</p>
<h2 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h2><p>线程：线程是操作系统级别的并发执行单位。每个线程都有自己的堆栈和寄存器上下文，可以在多个 CPU 核心上并行执行。线程通常是由操作系统调度和管理的。<br>协程：<strong>协程是在单个线程内部执行的轻量级任务</strong>。它们由开发人员显式地控制，可以通过挂起和恢复来实现多任务切换。</p>
<h2 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h2><ul>
<li>轻量级任务：协程是轻量级的任务，可以在单个线程内<strong>顺序执行</strong>。它们不需要创建额外的线程，因此不会引入多线程的同步和竞争条件问题。</li>
<li>异步操作：协程常用于处理异步操作，如加载资源、网络请求、延时执行等。通过协程，可以避免阻塞主线程，使应用保持响应性。</li>
<li>非阻塞执行：协程允许在不阻塞主线程的情况下执行代码。这对于需要等待某些条件满足或执行长时间运行的操作非常有用，而不会导致游戏卡顿。</li>
<li>多帧执行：协程的执行是<strong>分帧</strong>的，它可以*<em>在多个帧之间分散执行</em>。协程可以在代码中使用yield语句来指定何时暂停执行并等待条件满足，然后继续执行。</li>
<li>任务分割：协程使任务分割变得容易。可以将一个复杂的任务分解成多个协程，每个协程负责执行特定部分的任务，从而使代码更易于管理和理解。</li>
<li>事件处理：协程可以用于处理事件，如用户输入、碰撞检测等。例如，可以编写协程以在某个条件满足时触发特定的事件处理逻辑。</li>
<li>动画控制：协程常用于控制动画序列。例如，在游戏中，可以使用协程实现角色的平滑移动、淡入淡出效果等。</li>
<li>易于编写和调试：相对于多线程编程，协程通常更容易编写和调试。它们允许开发人员以顺序方式编写异步逻辑，而无需担心线程同步问题。</li>
<li>不适用于多核 CPU：协程在单线程内执行，因此无法充分利用多核 CPU。它适用于需要处理异步操作和控制流程的场景，但不适用于需要高度并行处理的性能密集型任务。</li>
</ul>
<h2 id="协程的底层原理"><a href="#协程的底层原理" class="headerlink" title="协程的底层原理"></a>协程的底层原理</h2><ul>
<li>调度器：Unity 引擎内部有一个协程调度器，用于管理和调度协程的执行。多个协程在主线程中以<strong>轮换分时</strong>的方式运行，这个调度器在主线程中运行，负责管理协程的生命周期和执行顺序，协程调度器会在每一帧中检查协程的状态，并决定哪一个协程应该继续执行。</li>
<li>协程方法：协程是通过<strong>迭代器</strong>来实现功能的，通过关键字 IEnumerator 来定义一个协程方法，返回 IEnumerator 类型，这是一个接口，表示一个可枚举的集合。<strong>当在 Unity 中启动协程时，实际上是向协程调度器注册了一个待执行的协程任务</strong>。</li>
<li>yield 指令：迭代方法必须包含 yield 语句，用于<strong>指定协程的挂起点</strong>。一个迭代方法中可以有多个 yield 语句，每个 yield 语句都表示协程的一个状态，这个状态可以是等待一段时间、等待一个条件满足、执行一个操作等。协程的执行过程实际上是一个<strong>状态机</strong>（State Machine），每个 yield 语句都表示协程的一个状态，每次访问时会基于状态知道当前应该执行哪一个 yield。</li>
<li>帧执行：协程任务在每一帧中执行。当一个协程任务被注册后，协程调度器会在每一帧中检查协程的状态，并根据 yield 语句的指令来控制协程的执行。</li>
<li>执行流程：当协程开始执行时，它会一直执行到遇到 yield 语句。在遇到 yield 后，协程会在当前帧结束后，或在等待的时间间隔过后，继续执行。这个过程会持续循环，直到协程执行完毕。</li>
</ul>
<p>总之，协程的核心概念是迭代器和 yield 关键字，而迭代器是一个特殊的C#方法，其返回值必须是 IEnumerator 接口。当你在协程方法中使用 yield 关键字，编译器会生成一个迭代器，将协程的执行分为多个状态。每个 yield 语句会导致生成一个状态，每个状态都会在调用 MoveNext 时执行一次。所以，一个 yield 语句通常会生成一个 MoveNext。这些状态在不同帧中检测当前帧是否满足协程所定义的条件，一旦满足，当前帧就会抽出 CPU 时间执行你所定义的协程迭代器的 MoveNext。</p>
<h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><h3 id="定义协程方法"><a href="#定义协程方法" class="headerlink" title="定义协程方法"></a>定义协程方法</h3><p>首先，你需要定义一个协程方法。这个方法的返回类型通常是 IEnumerator。协程方法内部可以包含yield语句，用于控制协程的执行流程。</p>
<p>不带参数的协程方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 协程的执行逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Coroutine executed!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带参数的协程方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutineWithArgs</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里使用传递的参数 value</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;Received value: &quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    <span class="comment">// 这里可以进行其他协程操作</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开启协程"><a href="#开启协程" class="headerlink" title="开启协程"></a>开启协程</h3><ul>
<li>StartCoroutine(string methodName)：这种方式使用协程方法的名称（字符串形式）来启动协程。适用于不需要参数的协程方法。<br>示例：<code>StartCoroutine(&quot;MyCoroutine&quot;);</code></li>
<li>StartCoroutine(IEnumerator routine)：这种方式通过协程方法的实际方法来启动协程。适用于带有参数的协程方法或不需要参数的协程方法。<br>示例1：<code>StartCoroutine(MyCoroutine());</code><br>示例2：<code>StartCoroutine(MyCoroutineWithArgs(1));</code></li>
<li>StartCoroutine(string methodName, object values)：这种方式使用协程方法的名称和参数（以object形式传递）来启动协程。适用于需要传递参数给协程方法的情况。<br>示例：<code>StartCoroutine(&quot;MyCoroutineWithArgs&quot;, someValue);</code></li>
</ul>
<h2 id="关闭协程"><a href="#关闭协程" class="headerlink" title="关闭协程"></a>关闭协程</h2><h3 id="StopCoroutine"><a href="#StopCoroutine" class="headerlink" title="StopCoroutine"></a>StopCoroutine</h3><ul>
<li><p>根据协程的方法名：可以使用方法的名称来停止协程，只需传递协程的方法名（作为字符串）给 StopCoroutine 方法。<br>示例：<code>StopCoroutine(&quot;MyCoroutine&quot;);</code></p>
</li>
<li><p>根据协程的引用：可以使用已经引用的协程的引用来停止它。<br>示例：</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IEnumerator myCoroutineInstance = MyCoroutine();</span><br><span class="line">StartCoroutine(myCoroutineInstance);</span><br><span class="line"><span class="comment">// 在需要的时候停止协程</span></span><br><span class="line">StopCoroutine(myCoroutineInstance);</span><br></pre></td></tr></table></figure>

<ul>
<li>根据协程返回的协程句柄：当你启动协程时，StartCoroutine 方法会返回一个协程句柄，你可以使用这个句柄来停止协程。<br>示例：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Coroutine myCoroutineHandle = StartCoroutine(MyCoroutine());</span><br><span class="line"><span class="comment">// 在需要的时候停止协程</span></span><br><span class="line">StopCoroutine(myCoroutineHandle);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：以下这样调用停不掉Coroutine。<br>StartCoroutine(Test1());<br>StopCoroutine(Test1());</p>
<p>StartCoroutine(Test2(1));<br>StopCoroutine(Test2(1));</p>
<p>StartCoroutine(Test3());<br>StopCoroutine(“Test3”);</p>
</blockquote>
<h3 id="StopAllCoroutines"><a href="#StopAllCoroutines" class="headerlink" title="StopAllCoroutines"></a>StopAllCoroutines</h3><p>请注意，使用 StopCoroutine 只会停止指定的协程。如果你有多个具有相同方法名的协程在运行，StopCoroutine 只会停止其中一个。如果要停止所有具有相同方法名的协程，可以使用 StopAllCoroutines。<br><code>StopAllCoroutines(); // 停止所有协程</code></p>
<blockquote>
<p>注意：将游戏对象的activeself设置为false时，可停掉此GameObject上的所有协程，并且再次激活时协程不会继续。但是将脚本的脚本enabled设置为false时，不可停掉协程。</p>
</blockquote>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>关键字在 C# 中用于创建协程，它可以在协程中暂停执行，然后在稍后的某个时间点恢复执行。以下是一些常见的 yield 使用方式：</p>
<h3 id="yield-0"><a href="#yield-0" class="headerlink" title="yield 0"></a>yield 0</h3><p>yield return 0; &#x2F;&#x2F;下一帧再执行后续代码<br>yield return 6;&#x2F;&#x2F;(任意数字) 下一帧再执行后续代码</p>
<h3 id="yield-return-null"><a href="#yield-return-null" class="headerlink" title="yield return null"></a>yield return null</h3><p>这是最常见的用法，用于等待一帧的时间，通常用于实现延迟操作。例如，yield return null; 可以使协程等待一帧后再执行下一步。</p>
<h3 id="yield-break"><a href="#yield-break" class="headerlink" title="yield break"></a>yield break</h3><p>该语句用于终止协程的执行。它允许你在协程中的任何地方显式地停止执行协程，就像 return 语句在常规函数中终止执行一样。当调用 yield break，协程将立即结束，不再执行后续的代码。这可以在协程的任何地方用于提前退出协程。</p>
<h3 id="yield-return-asyncOperation"><a href="#yield-return-asyncOperation" class="headerlink" title="yield return asyncOperation"></a>yield return asyncOperation</h3><p>等异步操作结束后再执行后续代码。注意，不是直接写 yield return asyncOperation，正确示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">AsyncOperation asyncOperation = SomeAsyncMethod();</span><br><span class="line"><span class="comment">// 在协程中等待异步操作完成</span></span><br><span class="line"><span class="keyword">while</span> (!asyncOperation.isDone) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步操作完成后执行下面的代码</span></span><br><span class="line">Debug.Log(<span class="string">&quot;Async operation is done.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="yield-return-new-WaitForSeconds-seconds"><a href="#yield-return-new-WaitForSeconds-seconds" class="headerlink" title="yield return new WaitForSeconds(seconds)"></a>yield return new WaitForSeconds(seconds)</h3><p>这用于等待指定的秒数。例如，<code>yield return new WaitForSeconds(2.0f);</code> 可以使协程等待 2 秒钟。</p>
<h3 id="yield-return-new-WaitForSecondsRealtime-seconds"><a href="#yield-return-new-WaitForSecondsRealtime-seconds" class="headerlink" title="yield return new WaitForSecondsRealtime(seconds)"></a>yield return new WaitForSecondsRealtime(seconds)</h3><p>与 WaitForSeconds 类似，但不受游戏暂停影响，用于在实时时间中等待一段时间。</p>
<h3 id="yield-return-new-WaitForFixedUpdate"><a href="#yield-return-new-WaitForFixedUpdate" class="headerlink" title="yield return new WaitForFixedUpdate()"></a>yield return new WaitForFixedUpdate()</h3><p>用于等待下一个固定帧更新（FixedUpdate）。<br>通常在物理更新或与物理相关的操作中使用。</p>
<h3 id="yield-return-new-WaitForEndOfFrame"><a href="#yield-return-new-WaitForEndOfFrame" class="headerlink" title="yield return new WaitForEndOfFrame()"></a>yield return new WaitForEndOfFrame()</h3><p>用于等待当前帧的结束，然后再执行下一步，通常在需要在渲染完成后执行某些操作时使用。</p>
<h3 id="yield-return-new-WWW-url"><a href="#yield-return-new-WWW-url" class="headerlink" title="yield return new WWW(url)"></a>yield return new WWW(url)</h3><p>用于等待从指定 URL 下载的内容（通常是网络请求）,在下载完成后继续执行协程。</p>
<h3 id="yield-return-StartCoroutine-MyCoroutine"><a href="#yield-return-StartCoroutine-MyCoroutine" class="headerlink" title="yield return StartCoroutine(MyCoroutine())"></a>yield return StartCoroutine(MyCoroutine())</h3><p>用于等待另一个协程完成执行，这可以用于协程的嵌套和顺序执行多个协程。</p>
<h3 id="yield-return-new-WaitUntil-x3D-gt-someCondition"><a href="#yield-return-new-WaitUntil-x3D-gt-someCondition" class="headerlink" title="yield return new WaitUntil(() &#x3D;&gt; someCondition)"></a>yield return new WaitUntil(() &#x3D;&gt; someCondition)</h3><p>用于等待某个条件变为真，可以在协程中等待直到给定条件满足。</p>
<h3 id="yield-return-new-WaitWhile-x3D-gt-someCondition"><a href="#yield-return-new-WaitWhile-x3D-gt-someCondition" class="headerlink" title="yield return new WaitWhile(() &#x3D;&gt; someCondition)"></a>yield return new WaitWhile(() &#x3D;&gt; someCondition)</h3><p>用于等待某个条件变为假，可以在协程中等待直到给定条件不满足。</p>
<h3 id="yield-return-new-YieldInstruction"><a href="#yield-return-new-YieldInstruction" class="headerlink" title="yield return new YieldInstruction()"></a>yield return new YieldInstruction()</h3><p>也可以创建自定义的 yield 指令，实现协程中的等待操作，YieldInstruction 是基类，也可以派生出自定义的等待条件。</p>
<p>这些 yield 使用方式可以帮助你在协程中实现不同类型的等待和延迟操作。通过合理使用 yield，你可以更好地控制协程的执行顺序和时机。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity对象池详解</title>
    <url>/2023/10/27/Unity/Unity%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>对象池模式是一种设计模式，通常用于管理和重用对象以提高性能和资源利用率。这模式非常适合在游戏开发中，特别是在处理大量相似对象实例的情况下。对象池模式的主要思想是在需要对象时从一个预先创建的对象池中获取对象，而不是在需要时创建新的对象实例。这可以减少内存分配和垃圾回收的开销，提高性能。今天我们就来详细介绍一下 Unity 中的对象池。</p>
<span id="more"></span>
<p>本篇文章使用的示例来自于B站阿严老师，将会结合提供的例子对对象池进行详细的解释。B站主页指路<a href="https://space.bilibili.com/27164588">https://space.bilibili.com/27164588</a>，Github项目指路<a href="https://github.com/AtCloudStudio/UnityObjectPoolTutorial">https://github.com/AtCloudStudio/UnityObjectPoolTutorial</a>。</p>
<h2 id="什么是对象池"><a href="#什么是对象池" class="headerlink" title="什么是对象池"></a>什么是对象池</h2><p>通常，在需要用到某个对象的时候，我们会分配一小块内存空间，new一个对象出来。示例：<code>Object object = new Object();</code>，在这个对象完成它的任务之后，我们将这个对象销毁，释放掉它占用的内存。<br>在Unity引擎中，这个过程就是我们需要一个对象时，通过实例化来生成，不需要这个对象时，通过 Destroy 进行销毁，Unity 引擎的垃圾回收系统会自动为我们完成 GC 的工作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">GameObject gameObject = Instantiate(prefab);</span><br><span class="line"><span class="comment">//销毁游戏对象</span></span><br><span class="line">Destroy(gameObject);</span><br></pre></td></tr></table></figure>

<p>但这样做有一个明显的问题，当游戏中需要频繁地创建和销毁游戏对象时，GC 就会消耗较多的运行性能，耗费大量的 CPU 时间。例如对一个横板射击游戏，我们如果频繁地同时生成成百上千个子弹，再频繁地销毁，那么游戏就会变得十分卡顿，甚至崩溃。</p>
<p>而对象池就是一种用于在重复创建和销毁游戏对象时，减少资源和内存开销常用的性能优化技术。对象池的原理很简单，在程序运行的初始阶段，先取出一块完整的内存空间，用来预先创建一组游戏对象，让它们预备好随时被启用；当需要一个对象时，我们不再new一个新对象，而是从池中获取一个空闲的对象，对其进行配置和激活；当我们不再需要这个对象时，对象池并不销毁对象，而是将对象设置为不活跃状态，回收到池中，下次需要的时候再次从池中拿出来。这种重用机制减少了内存分配和垃圾回收的开销，提高了游戏性能和资源利用。</p>
<h2 id="为什么使用对象池"><a href="#为什么使用对象池" class="headerlink" title="为什么使用对象池"></a>为什么使用对象池</h2><p>使用对象池的主要原因是优化游戏性能和资源管理。</p>
<ul>
<li><p>减少内存分配和垃圾回收：在游戏中频繁创建和销毁对象会导致内存分配和垃圾回收，这些操作会占用宝贵的CPU时间并引起性能下降。对象池通过重用已创建的对象，减少了这些开销。</p>
</li>
<li><p>提高性能：频繁的对象实例化和销毁可能会导致游戏的帧率下降，特别是在移动设备等资源有限的平台上。对象池可以减轻这种性能问题，使游戏更流畅。</p>
</li>
<li><p>避免资源加载和卸载：对象池在游戏启动时一次性加载对象，而不是在需要时加载。这可以减少加载和卸载资源的次数，从而加快游戏启动时间和场景切换。</p>
</li>
<li><p>平滑游戏体验：使用对象池可以避免对象创建时的瞬间性能峰值，使游戏体验更平滑，不会有明显的卡顿。</p>
</li>
<li><p>快速对象重用：对象池允许您快速获取已创建并配置好的对象，节省了初始化和配置对象的时间，特别是在需要频繁生成相似对象的情况下。</p>
</li>
<li><p>资源节约：通过重复使用对象，可以降低游戏的内存占用，从而允许游戏在资源受限的环境中运行。</p>
</li>
</ul>
<h2 id="Unity-ObjectPool详解"><a href="#Unity-ObjectPool详解" class="headerlink" title="Unity ObjectPool详解"></a>Unity ObjectPool详解</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Pool;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectPool</span>(<span class="params">Func&lt;T&gt; createFunc, </span></span></span><br><span class="line"><span class="params"><span class="function">  Action&lt;T&gt; actionOnGet = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  Action&lt;T&gt; actionOnRelease = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  Action&lt;T&gt; actionOnDestroy = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">bool</span> collectionCheck = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">int</span> defaultCapacity = <span class="number">10</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">int</span> maxSize = <span class="number">10000</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>参数列表解释</p>
<ul>
<li><code>Func&lt;T&gt; createFunc</code><br>这是一个委托，用于自定义在需要新对象时如何创建对象的方法。需填入一个带泛型T类型返回值的方法，返回一个类型为 T 的新对象。例如，可以传递一个 lambda 表达式，或者引用一个创建新对象的方法。</li>
<li><code>Action &lt;T&gt; actionOnGet</code><br>这是一个委托，定义在从池中获取对象（出池）时应执行的操作。它通常用于初始化对象的状态，例如设置位置、旋转等。可以将其留空（null）以不执行任何操作。</li>
<li><code>Action &lt;T&gt; actionOnRelease</code><br>这是一个委托，定义在将对象放回到池中（进池）时应执行的操作。它通常用于重置对象的状态，以备下次重用。可以将其留空（null）以不执行任何操作。</li>
<li><code>Action &lt;T&gt; actionOnDestroy</code><br>这是一个委托，定义在销毁对象时应执行的操作，比如在 actionOnDestroy 中通过 Destroy() 方法将因为池满而不能入池的对象直接删除，可以将其留空（null）以不执行任何操作。</li>
<li><code>bool collectionCheck</code><br>设定是否开启对象回收检测功能，设为真则在进池前检查对象是否已经存在池中。</li>
<li><code>int defaultCapacity</code><br>这是对象池的默认初始容量，即在对象池创建时池的大小。</li>
<li><code>int maxSize</code><br>这是对象池的最大容量。如果对象池中的对象数达到最大容量时，无法再把新对象存入对象池。注意，当对象池中的对象个数不足以满足 Get() 函数所需要的对象个数时，对象时就会调用第一个参数定义的函数，来创建出新的可用对象；因此 maxSize 这个参数并不能阻止对象池创建出新的对象，仅仅是阻止它存入更多的对象，这个参数防止栈所占用的内存无限地增长。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>int CountAll<br>只读属性，初始值为0。当前启用中的对象与存储在对象池中的对象的个数总和，为 CountActive 属性与 CountInactive 属性之和，每调用一次 createFunc 委托该值就会 + 1。</li>
<li>int CountActive<br>只读属性，初始值为0。对象池创建的，但现在正在启用中，还没有返回对象池的对象个数，每调用一次 Release() 方法就会 - 1，Get() 方法 + 1。</li>
<li>int CountInactive<br>只读属性，初始值为0。存储在栈中的等待被启用的对象个数，也是实际会占用对象池容量的对象，每调用一次 Release() 方法就会 + 1，Get() 方法 - 1，最大值为池的最大容量。</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>T Get()<br>该方法用于出池，它会尝试从对象池中获取一个对象。如果对象池为空（没有可用的对象），它将调用 createFunc 来创建一个新对象，然后将其返回。在需要对象时调用，而不必关心对象是否存在或者已被销毁。</li>
<li>void Release(T element)<br>这个方法用于进池，即将对象返回到对象池中。它接受一个对象 element，如果池未达到最大容量，它将把该对象放回池中以供后续重用。如果池已满，它将触发 actionOnDestroy 事件（如果定义了的话），通常用于销毁对象或执行其他清理操作。</li>
<li>void Clear()<br>这个方法用于清空整个对象池，即将池中的所有对象都销毁或释放。这对于在场景切换或游戏状态改变时进行对象池的清理非常有用。</li>
</ul>
<h2 id="运用对象池的宝石生成器"><a href="#运用对象池的宝石生成器" class="headerlink" title="运用对象池的宝石生成器"></a>运用对象池的宝石生成器</h2><p>这是一个运用了 Unity 对象池来进行管理的宝石生成器 demo ，我们将通过这个 demo，来加深对对象池应用的理解。demo 运行画面如图所示，场景某个位置有一个生成五颜六色宝石的生成器，当宝石落到地面后一段时间，宝石会消失。<br><img src="/../../images/pic5/gem_gen.png" alt="demo画面"></p>
<h3 id="宝石预制体脚本"><a href="#宝石预制体脚本" class="headerlink" title="宝石预制体脚本"></a>宝石预制体脚本</h3><p>宝石落地时，触发 OnTriggerEnter()，落地后开始计时，到达设置的宝石消失时间时，执行 deactivateAction 。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Gem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> lifeTimeAfterLanding = <span class="number">2f</span>;</span><br><span class="line">    <span class="built_in">bool</span> hasLanded;</span><br><span class="line">    <span class="built_in">float</span> deactivateTimer;</span><br><span class="line">    System.Action&lt;Gem&gt; deactivateAction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasLanded) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        deactivateTimer += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (deactivateTimer &gt;= lifeTimeAfterLanding)</span><br><span class="line">        &#123;</span><br><span class="line">            deactivateTimer = <span class="number">0f</span>;</span><br><span class="line">            deactivateAction.Invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        hasLanded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        hasLanded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDeactivateAction</span>(<span class="params">System.Action&lt;Gem&gt; deactivateAction</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.deactivateAction = deactivateAction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="没有使用对象池的普通版本"><a href="#没有使用对象池的普通版本" class="headerlink" title="没有使用对象池的普通版本"></a>没有使用对象池的普通版本</h3><p>使用一个数组，存储不同的宝石预制体。设置一个发射时间和发射数量。在 Update() 中计时，每经过一段时间等于发射时间时，执行一个 Spawn() 发射宝石。<br>Spawn() 函数中做的事情就是创建指定数量个宝石对象，宝石种类随机，设置一个球体内的随机空间坐标作为宝石的产生坐标，并将 Destory() 作为委托的处理函数，传给gem对象，作为销毁宝石时执行的操作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GemSpawnerNormalVersion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Gem[] gemPrefabs;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> spawnAmount = <span class="number">50</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> spawnInterval = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> spawnTimer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spawnTimer += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (spawnTimer &gt;= spawnInterval)</span><br><span class="line">        &#123;</span><br><span class="line">            spawnTimer = <span class="number">0f</span>;</span><br><span class="line">            Spawn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Spawn</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; spawnAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> randomIndex = Random.Range(<span class="number">0</span>, gemPrefabs.Length);</span><br><span class="line">            <span class="keyword">var</span> prefab = gemPrefabs[randomIndex];</span><br><span class="line">            <span class="keyword">var</span> gem = Instantiate(prefab, transform);</span><br><span class="line"></span><br><span class="line">            gem.transform.position = transform.position + Random.insideUnitSphere * <span class="number">2f</span>;</span><br><span class="line">            gem.SetDeactivateAction(<span class="built_in">delegate</span> &#123; Destroy(gem.gameObject); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Hierarchy 面板，我们可以看到创建的宝石数量越来越多，并且如果宝石发射的数量值设的较大，间隔时间较短，销毁较慢，画面还会越来越卡顿。</p>
<h3 id="使用对象池的优化版本"><a href="#使用对象池的优化版本" class="headerlink" title="使用对象池的优化版本"></a>使用对象池的优化版本</h3><h4 id="创建单一宝石对象池"><a href="#创建单一宝石对象池" class="headerlink" title="创建单一宝石对象池"></a>创建单一宝石对象池</h4><p>首先，我们先从创建一个单一预制体的 GemPool 做起。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GemPool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Gem prefab;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> defalutSize = <span class="number">100</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxSize = <span class="number">200</span>;</span><br><span class="line">    ObjectPool&lt;Gem&gt; pool; <span class="comment">//一个基于Stack的对象池系统</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建对象池</span></span><br><span class="line">        pool = <span class="keyword">new</span> ObjectPool&lt;Gem&gt;(</span><br><span class="line">            OnCreatePoolItem, </span><br><span class="line">            OnGetPoolItem, </span><br><span class="line">            OnReleasePoolItem, </span><br><span class="line">            OnDestroyPoolItem, </span><br><span class="line">            <span class="literal">true</span>, </span><br><span class="line">            defalutSize,</span><br><span class="line">            maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gem = pool.Get(); <span class="comment">//每帧创建一个宝石</span></span><br><span class="line">        gem.transform.position = transform.position + Random.insideUnitSphere * <span class="number">2f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Gem <span class="title">OnCreatePoolItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gem = Instantiate(prefab, transform);</span><br><span class="line">        <span class="comment">//宝石创建之后，调用设定禁用函数，在委托处理函数中，调用对象池的Release函数而不是直接销毁</span></span><br><span class="line">        gem.SetDeactivateAction(<span class="built_in">delegate</span> &#123; pool.Release(gem); &#125;);</span><br><span class="line">        <span class="keyword">return</span> gem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">Gem obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//激活宝石</span></span><br><span class="line">        obj.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnReleasePoolItem</span>(<span class="params">Gem obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//隐藏宝石</span></span><br><span class="line">        obj.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroyPoolItem</span>(<span class="params">Gem obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//销毁宝石</span></span><br><span class="line">        <span class="comment">//注意，当对象池运行时，宝石对象的状态会不断在激活和隐藏中切换，不会主动销毁，除非我们主动清空对象池</span></span><br><span class="line">        <span class="comment">//或者对象池中的宝石数量已经达到最大值，才会对试图返回对象池的对象进行销毁</span></span><br><span class="line">        Destroy(obj.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示，我们可以得到一个单一宝石的对象池，在 hierachy 面板可以看到，宝石对象在启用与禁用之间来回切换状态，并且游戏对象的数目逐渐趋于稳定。<br><img src="/../../images/pic5/gem_pool_single.png" alt="单一宝石对象池"><br>我们使用 Ctrl + 7 快捷键打开 Profiler 分析器查看，可以发现除了一开始宝石实例化时产生了一些 GC，当前帧的垃圾回收与内存重新分配的值是0，说明对象池稳定运行之后，不会再实例化新的宝石预制体出来，确实没有再产生额外的内存分配和垃圾回收消耗。<br><img src="/../../images/pic5/gc.png" alt="GC分析"></p>
<h4 id="创建泛型类的基础对象池"><a href="#创建泛型类的基础对象池" class="headerlink" title="创建泛型类的基础对象池"></a>创建泛型类的基础对象池</h4><p>我们根据单一对象池脚本进行优化，写一个泛型类的基础对象池，不仅能用于 Gem 类，也能用于其他类，并且将 GemPool 类进行优化，继承 BasePool。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasePool</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] T prefab;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> defaultSize = <span class="number">100</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxSize = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    ObjectPool&lt;T&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ActiveCount =&gt; pool.CountActive;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> InactiveCount =&gt; pool.CountInactive;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TotalCount =&gt; pool.CountAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">bool</span> collectionCheck = <span class="literal">true</span></span>)</span> =&gt; </span><br><span class="line">        pool = <span class="keyword">new</span> ObjectPool&lt;T&gt;(OnCreatePoolItem, OnGetPoolItem, OnReleasePoolItem, OnDestroyPoolItem, collectionCheck, defaultSize, maxSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> T <span class="title">OnCreatePoolItem</span>()</span> =&gt; Instantiate(prefab, transform);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">T obj</span>)</span> =&gt; obj.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReleasePoolItem</span>(<span class="params">T obj</span>)</span> =&gt; obj.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroyPoolItem</span>(<span class="params">T obj</span>)</span> =&gt; Destroy(obj.gameObject);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>()</span> =&gt; pool.Get();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params">T obj</span>)</span> =&gt; pool.Release(obj);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span> =&gt; pool.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当某个类需要用到对象池时，我们只需要继承 BasePool 类，然后在 Awake() 函数中调用 Initialize 初始化方法，就可以使用对象池系统了。对象池初始化时的这几个委托处理函数，添加了 protected virtual 修饰符，这时继承这个类的子类就可以对这些函数进行重写了。Get(), Release(T obj), Clear() 方法使用了 unity 对象池本身对应的方法，子类可以直接调用这几个方法来使用这个对象池系统。<br>修改后的 GemPool 类示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GemPool</span> : <span class="title">BasePool</span>&lt;<span class="title">Gem</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Gem <span class="title">OnCreatePoolItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gem = <span class="keyword">base</span>.OnCreatePoolItem();</span><br><span class="line">        gem.SetDeactivateAction(<span class="built_in">delegate</span> &#123; Release(gem); &#125;);</span><br><span class="line">        <span class="keyword">return</span> gem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">Gem gem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnGetPoolItem(gem);</span><br><span class="line">        gem.transform.position = transform.position + Random.insideUnitSphere * <span class="number">2f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，得到的示例效果和之前没有使用 BasePool 时相同：<br><img src="/../../images/pic5/base_pool.png" alt="BasePool"></p>
<h4 id="实现多种类宝石对象池管理"><a href="#实现多种类宝石对象池管理" class="headerlink" title="实现多种类宝石对象池管理"></a>实现多种类宝石对象池管理</h4><p>我们可以为每一种预制体构建一个宝石对象池，同样用数组来存储宝石预制体。每种类型的宝石我们都创建一个空对象，作为该类宝石的父物体，将生成的宝石放在对应的父对象下，并且在这个父对象上添加 GemPool 脚本。但因为这些脚本是运行时实时添加的，所以它的预制体变量是空的，因此，我们还需要在 GemPool 中提供一个 SetPrefab 方法，用来把宝石预制体数组里的预制体赋值给 GemPool 类。</p>
<p>宝石对象池管理类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GemSpawnerPoolVersion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Gem[] gemPrefabs;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> spawnAmount = <span class="number">50</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> spawnInterval = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> spawnTimer;</span><br><span class="line"></span><br><span class="line">    List&lt;GemPool&gt; gemPools = <span class="keyword">new</span> List&lt;GemPool&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> prefab <span class="keyword">in</span> gemPrefabs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> poolHolder = <span class="keyword">new</span> GameObject(<span class="string">$&quot;Pool: <span class="subst">&#123;prefab.name&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            poolHolder.transform.parent = transform;</span><br><span class="line">            poolHolder.transform.position = transform.position;</span><br><span class="line">            poolHolder.SetActive(<span class="literal">false</span>); <span class="comment">//由于对象池是在Awake中初始化的，还没有prefab，所以先禁用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> pool = poolHolder.AddComponent&lt;GemPool&gt;();</span><br><span class="line">            </span><br><span class="line">            pool.SetPrefab(prefab);</span><br><span class="line">            poolHolder.SetActive(<span class="literal">true</span>); <span class="comment">//设置完prefab再启用</span></span><br><span class="line">            gemPools.Add(pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spawnTimer += Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (spawnTimer &gt;= spawnInterval)</span><br><span class="line">        &#123;</span><br><span class="line">            spawnTimer = <span class="number">0f</span>;</span><br><span class="line">            Spawn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Spawn</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; spawnAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//随机选择一种宝石，然后从该宝石对应的对象池中取出宝石</span></span><br><span class="line">            <span class="keyword">var</span> randomIndex = Random.Range(<span class="number">0</span>, gemPrefabs.Length);</span><br><span class="line">            <span class="keyword">var</span> pool = gemPools[randomIndex];</span><br><span class="line">            pool.Get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宝石对象池类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GemPool</span> : <span class="title">BasePool</span>&lt;<span class="title">Gem</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Gem <span class="title">OnCreatePoolItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gem = <span class="keyword">base</span>.OnCreatePoolItem();</span><br><span class="line">        gem.SetDeactivateAction(<span class="built_in">delegate</span> &#123; Release(gem); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">Gem gem</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnGetPoolItem(gem);</span><br><span class="line">        gem.transform.position = transform.position + Random.insideUnitSphere * <span class="number">2f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetPrefab</span>(<span class="params">Gem prefab</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.prefab = prefab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了对比普通版本和对象池版本的性能差异，我们要保持和普通版本相同的数值配置。<br>普通版本（没有使用对象池）可以看到随着时间的推行，帧率逐渐下降，最终维持在一个较低值，甚至可能崩溃，并且可以看到持续产生了大量的 GC，游戏画面卡顿。<br><img src="/../../images/pic5/normal.png" alt="普通版本"><br>而使用了对象池的版本可以看到随着时间的推行，帧率逐渐稳定，并且除了一开始创建实例时，之后基本不会再产生 GC （除非超过对象池最大值，有对象被创建和销毁，偶尔会产生 GC），游戏运行流畅。<br><img src="/../../images/pic5/pool.png" alt="对象池版本"></p>
<blockquote>
<p>注意：Unity 自带的对象池也有一个问题，就是没有预创建对象，一开始对象池是空的，一边运行一边才往对象池中加入对象，这个问题可以通过预先自创建对象来解决。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，对象池可以大幅提高性能。在游戏中频繁创建和销毁对象会导致内存分配和垃圾收集的压力，降低帧率，使游戏不流畅。使用对象池，可以避免这种性能瓶颈，因为对象已经被创建，只需激活和停用，减少了开销，提高了游戏的响应速度。其次，对象池有助于内存优化。对象池管理对象的生命周期，确保对象的内存分配只发生一次，避免了内存碎片化和泄漏问题。这意味着游戏更加稳定，减少了因内存问题引起的崩溃风险。<br>对象池适用于各种游戏场景，无论是在敌人生成、子弹发射、粒子效果还是UI元素中，对象池都可以发挥作用。它提供了一种通用的方法，适用于各种游戏元素的管理和重复使用。<br>最重要的是，对象池是相对容易实施和维护的。现代游戏引擎如Unity提供了丰富的工具和资源来支持对象池的创建和管理。一旦设置，对象池通常需要很少的维护，但可以显著改善游戏性能。<br>综上所述，对象池是一项强大的技术，可以提高游戏的性能、降低内存开销、确保游戏的流畅性，适用于各种游戏场景，并且易于实施和维护。它是现代游戏开发中不可或缺的工具，有助于提供更出色的游戏体验。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity状态机详解</title>
    <url>/2023/10/28/Unity/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<p>状态机（State Machine）全称为有限状态自动机，是一种计算机科学和工程领域中的建模工具，也是一种用于描述对象的不同状态以及状态之间转换的数学模型。状态机在各种应用中都有广泛的应用，包括软件开发、游戏设计、自动控制系统等。在实际编程中，我们将这种数学模型的运用称为状态机设计模式，简称状态模式。在Unity引擎中运用最明显的例子就是Animator动画器。今天，我们就来详细介绍一下状态机。</p>
<span id="more"></span>
<h2 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h2><p>状态机是一种抽象模型，通常用于描述对象、系统或程序的行为方式。它包括一组可能的状态，每个状态代表对象或系统的一种特定情况或条件，以及规定了在给定条件下如何从一个状态切换到另一个状态的转换规则。这些规则通常依赖于外部输入事件或信号，即状态机会响应这些事件触发状态之间的转换。此外，状态机还可以定义在状态转换时执行的动作或任务，例如状态改变时发送消息、执行计算或触发其他操作。<br>简单来说状态机就是用于描述事物不同状态之间如何互相转换的模型。</p>
<h2 id="为什么要使用状态机"><a href="#为什么要使用状态机" class="headerlink" title="为什么要使用状态机"></a>为什么要使用状态机</h2><p>在Unity游戏开发中，使用状态机是一种强大的方法，用于管理游戏对象的行为和状态。接下来让我们举一个简单的例子来说明为什么要使用状态机。<br>当你想制作一个敌人角色，可能有如下一些状态，例如：</p>
<ul>
<li>徘徊状态：敌人在一个区域内徘徊，不主动攻击玩家。</li>
<li>追击状态：敌人发现玩家后，开始主动追击玩家。</li>
<li>攻击状态：敌人接近玩家一定距离后，开始攻击玩家。</li>
<li>死亡状态：敌人被击败后，进行死亡动画并禁用。</li>
</ul>
<p>如果没有状态机，会产生什么问题呢？</p>
<ul>
<li>大量的if-else语句<br>我们可能需要在 update 中编写大量的 if-else 语句编写大量的 if-else 语句或开关语句来检查敌人的状态并执行相应的行为。例如，为了处理敌人的不同状态（徘徊、追击、攻击、死亡），往往需要创建大量的条件判断。这会导致代码的可读性下降，难以理解和维护。</li>
<li>状态之间的影响和纠缠<br>在没有状态机的情况下，不同状态之间的切换和影响可能会变得混乱。例如，当敌人从追击状态切换到攻击状态时，需要确保适当地停止追击、开始攻击，并且不会触发错误的行为。这种状态之间的相互作用可能会导致难以调试的问题，因为需要在多个位置管理状态切换和影响。</li>
<li>功能难以拓展<br>如果我们希望添加新的状态或更多的行为，而没有使用状态机，那么每次增加新功能都会变得繁琐。我们需要修改和添加更多的 if-else 语句，同时需要小心确保不会影响现有的行为，这会导致代码的膨胀和难以维护。</li>
<li>可读性差，不利于团队合作<br>在缺少状态机时，代码将变得难以理解，因为所有的状态判断和行为都集中在一起，没有明确的结构。这降低了代码的可读性，使团队合作和维护变得更加复杂。</li>
</ul>
<p>总的来说，没有状态机的情况下，我们将面临编写冗长、复杂、难以扩展和难以维护的代码。状态机的使用可以有效地解决这些问题，提高代码的可读性、可维护性，同时使添加新状态和行为变得更加容易。状态机提供了一种清晰的结构，使游戏对象的状态管理更加直观和可控。</p>
<h2 id="状态机的组成部分"><a href="#状态机的组成部分" class="headerlink" title="状态机的组成部分"></a>状态机的组成部分</h2><p>状态机通常由以下几个基本组成部分构成：</p>
<ul>
<li>状态：状态是状态机的核心组成部分，代表了对象、系统或程序可能处于的不同情况或条件。每个状态通常有一个唯一的标识符，并与特定的行为或属性相关联，描述对象或系统的不同情况。</li>
<li>转换：转换是描述状态之间的切换规则的一组规则。规定了状态之间的切换条件和规则。转换描述了当特定事件发生时，从一个状态切换到另一个状态的方式。转换规则通常包括定义触发条件以及指定目标状态，转换是状态之间的过渡。</li>
<li>事件：事件是触发状态之间切换的信号或条件。事件可以是外部输入，如玩家的操作，也可以是内部触发条件，如定时事件或特定的系统条件。</li>
<li>动作：在状态机的特定状态切换中，可以定义执行的动作或任务。这些动作可以包括更新状态、发送消息、执行计算、启动动画或触发其他操作。动作通常与状态转换相关联，以确保状态之间的平稳过渡。</li>
<li>初始状态：初始状态定义了状态机的初始状态，即对象、系统或程序在启动时所处的状态。状态机通常从初始状态开始，然后根据触发条件逐渐切换到其他状态。</li>
<li>终止状态：终止状态表示状态机的结束状态，当状态机达到终止状态时，它可能会执行最终的清理操作或结束自身。终止状态并不是每个状态机都必须包含的元素，但在某些情况下它们是有用的。</li>
<li>上下文数据：状态机可能需要访问和维护一些上下文数据，以在不同状态之间共享信息。这些数据可以用于存储对象属性、计数、计时器等，以影响状态机的行为。</li>
</ul>
<p>让我们以操控一个游戏角色进行跑和跳的情境来解释状态机的各个关键组成部分：</p>
<ul>
<li>状态：在这个例子中，可能存在以下两个状态。①”跑”状态：当玩家控制角色按下移动键时，角色处于跑步状态；②”跳”状态：当玩家按下跳跃键时，角色处于跳跃状态。</li>
<li>转换：①从”跑”状态到”跳”状态的转换：当玩家按下跳跃键（事件）时，发生状态从”跑”到”跳”的转换；②从”跳”状态到”跑”状态的转换：当角色着陆（事件）后，状态从”跳”转回到”跑”。</li>
<li>事件：在这个情境中，事件可以是①”跳跃键按下”：触发从”跑”到”跳”的状态转换；②”角色着陆”：触发从”跳”到”跑”的状态转换。</li>
<li>动作：①在”跳”状态中，动作可能包括播放跳跃动画、应用重力、移动角色位置；②在”跑”状态中，动作可能包括播放跑步动画、移动角色位置。</li>
<li>初始状态：初始状态指定了状态机的启动状态。在这个例子中，可能的初始状态是”跑”状态。当游戏开始时，角色默认处于跑状态。</li>
<li>终止状态：在某些情境下，可能有终止状态，但在这个特定情境中，终止状态不是必需的。</li>
<li>上下文数据：例如，角色的速度、跳跃高度等属性可以被多个状态访问和修改，以影响角色的行为。</li>
</ul>
<p>这些组成部分共同构成了状态机，用于管理游戏角色的不同行为状态和状态之间的切换。在这个示例中，状态机使游戏开发人员能够清晰地定义和控制角色的行为，确保跑和跳的行为按预期进行。</p>
<h2 id="一个基于状态机的demo示例"><a href="#一个基于状态机的demo示例" class="headerlink" title="一个基于状态机的demo示例"></a>一个基于状态机的demo示例</h2><p>接下来我们使用的示例同样来自于B站阿严老师，B站主页指路<a href="https://space.bilibili.com/27164588">https://space.bilibili.com/27164588</a>。demo内容是基于状态机模式，控制 unity 酱进行一些简单的跑跳行为。</p>
<h3 id="不使用状态机的普通版本"><a href="#不使用状态机的普通版本" class="headerlink" title="不使用状态机的普通版本"></a>不使用状态机的普通版本</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponentInChildren&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果按住A键或D键</span></span><br><span class="line">        <span class="keyword">if</span>(Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.Play(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 松开按键时</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.Play(<span class="string">&quot;Idle&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着状态的增多，我们需要在 Update 里写越来越多的if-else，而且某些状态还可能会相互制约，例如只有在地面上时，我们才能跳跃或者移动；只有在跑步状态时，我们松开按键才能回到空闲状态。于是我们只能声明一个个的 bool 值，来判断当前属于什么状态，很容易被一大堆互相限制的逻辑搞晕。</p>
<h3 id="使用状态机的版本"><a href="#使用状态机的版本" class="headerlink" title="使用状态机的版本"></a>使用状态机的版本</h3><h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><h5 id="IState接口"><a href="#IState接口" class="headerlink" title="IState接口"></a>IState接口</h5><p>通过这个接口，我们定义一个状态必有的几种方法，即状态的进入，退出，逻辑更新，物理更新（我们通过刚体模拟物体运动）。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Enter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exit</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PhysicUpdate</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StateMachineBase"><a href="#StateMachineBase" class="headerlink" title="StateMachineBase"></a>StateMachineBase</h5><p>定义状态机基类。状态机类的功能主要有两点：①持有所有的状态类，并对它们进行管理和切换；②负责进行当前状态的更新。我们使用字典来映射到具体的状态上。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StateMachineBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    IState currentState; </span><br><span class="line">    <span class="comment">//设置一个状态表，可以根据state的Type获取到对应的state</span></span><br><span class="line">    <span class="keyword">protected</span> Dictionary&lt;System.Type, IState&gt; stateTable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行当前状态的逻辑更新；</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行当前状态的物理更新；</span></span><br><span class="line">        currentState.PhysicUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SwitchOn</span>(<span class="params">IState newState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前状态的启动，我们将在这个类的子类中调用这个方法，因此添加protected修饰符</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        currentState.Enter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">IState newState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前状态的切换，和启动函数不同的是，我们进行状态切换时，需要先退出当前状态</span></span><br><span class="line">        currentState.Exit();</span><br><span class="line">        SwitchOn(newState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入字典key值的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">System.Type newState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SwitchState(stateTable[newState]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h4><h5 id="PlayerState玩家状态类"><a href="#PlayerState玩家状态类" class="headerlink" title="PlayerState玩家状态类"></a>PlayerState玩家状态类</h5><p>定义玩家状态类，继承 IState 接口，同时继承 ScriptableObject，让我们更方便的管理玩家的状态。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.PlayerLoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerState</span> : <span class="title">ScriptableObject</span>, <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Animator animator; <span class="comment">//执行动画切换</span></span><br><span class="line">    <span class="keyword">protected</span> PlayerStateMachine stateMachine; <span class="comment">//执行状态切换</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">Animator animator, PlayerStateMachine stateMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个用来接收这两个变量的公有方法</span></span><br><span class="line">        <span class="keyword">this</span>.animator = animator;</span><br><span class="line">        <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法可以先留空，在子类中重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PhysicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="玩家状态机类"><a href="#玩家状态机类" class="headerlink" title="玩家状态机类"></a>玩家状态机类</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerStateMachine</span> : <span class="title">StateMachineBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为了避免每次都要通过代码添加新状态，我们使用一个数组来存储所有的状态类，可以在Inspector面板直接管理</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] PlayerState[] playerStates;</span><br><span class="line">    Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponentInChildren&lt;Animator&gt;();</span><br><span class="line">        stateTable = <span class="keyword">new</span> Dictionary&lt;System.Type, IState&gt;(playerStates.Length);</span><br><span class="line">        <span class="comment">//状态的初始化</span></span><br><span class="line">        <span class="keyword">foreach</span>(PlayerState playerState <span class="keyword">in</span> playerStates)</span><br><span class="line">        &#123;</span><br><span class="line">            playerState.Initialize(animator, <span class="keyword">this</span>);</span><br><span class="line">            stateTable.Add(playerState.GetType(), playerState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以idle作为初始状态</span></span><br><span class="line">        SwitchOn(stateTable[<span class="keyword">typeof</span>(PlayerState_Idle)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Idle状态"><a href="#Idle状态" class="headerlink" title="Idle状态"></a>Idle状态</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Data/StateMachine/PlayerState/Idle&quot;</span>, fileName = <span class="string">&quot;PlayerState_Idle&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerState_Idle</span> : <span class="title">PlayerState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Enter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(<span class="string">&quot;Idle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed)</span><br><span class="line">        &#123;</span><br><span class="line">            stateMachine.SwitchState(<span class="keyword">typeof</span>(PlayerState_Run));     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Run状态"><a href="#Run状态" class="headerlink" title="Run状态"></a>Run状态</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Data/StateMachine/PlayerState/Run&quot;</span>, fileName = <span class="string">&quot;PlayerState_Run&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerState_Run</span> : <span class="title">PlayerState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Enter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed))</span><br><span class="line">        &#123;</span><br><span class="line">            stateMachine.SwitchState(<span class="keyword">typeof</span>(PlayerState_Idle));      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态机的优缺点"><a href="#状态机的优缺点" class="headerlink" title="状态机的优缺点"></a>状态机的优缺点</h2><p>使用状态机在游戏开发和软件设计中具有多个优点：</p>
<ul>
<li>结构清晰：状态机提供了清晰的结构，使代码易于组织和理解。每个状态和状态之间的转换都可以明确定义，使代码更易于阅读和维护。</li>
<li>易于扩展：添加新状态或行为时，状态机使修改代码更加简单和可控。你只需创建新状态并定义状态之间的转换规则，而不必修改现有的大量代码。</li>
<li>降低复杂性和耦合性：状态机将复杂性分解为更小的、可管理的部分。每个状态只关注自己的行为，这减少了状态之间的相互干扰和错误，我们不需要考虑状态间的相互制约，只需要去思考当前状态如何切换到下一个状态，降低了耦合性。</li>
<li>可重用性：状态机中的状态和转换规则通常可以在不同对象或角色之间重复使用。这提高了代码的可重用性，减少了冗余。</li>
<li>容易维护：当需要调整游戏对象的行为时，只需关注状态机的定义，而不必搜索整个代码库来查找和修改相关代码。</li>
<li>增加可读性：状态机提供了一种自然的方式来描述对象的行为。通过查看状态机，开发人员和团队可以快速了解对象可能的状态和行为。</li>
<li>容易调试：由于状态机的状态切换和行为是明确定义的，因此在调试和查找问题时更容易定位和解决错误。</li>
<li>可视化工具：许多游戏引擎，包括Unity，提供了可视化工具来创建和管理状态机，使开发人员能够直观地定义状态和转换，而无需编写大量代码。</li>
</ul>
<p>同时，使用状态机也有一些缺点：</p>
<ul>
<li>针对每一个状态，我们都需要创建一个类来存储数据，造成了文件数量增多，所以使用状态机对文件规范整理的要求很高。</li>
<li>代码重复。</li>
</ul>
<p>总之，使用状态机有助于简化代码、提高可维护性、降低复杂性，同时提供更清晰的结构，这对于游戏开发和软件设计都是非常有益的。状态机是一种强大的工具，可用于管理对象、角色或系统的不同状态和行为，帮助开发人员更好地组织和控制复杂性。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Unity中的存档系统</title>
    <url>/2023/10/23/Unity/%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Unity中的存档系统用于保存和加载游戏的状态、进度和设置。存档系统通常用于实现游戏的保存和载入功能，以便玩家可以在游戏中保存当前状态，然后稍后重新加载。<br>Unity读档与存档采用的储存方式主要有PlayerPrefs，外部文件，云储存等，存储形式有直接存储数据、序列化(Binary、Xml、Json)，自定义序列化格式等，数据存储过程一般需要加密。本文介绍一些常用的数据存档方式。</p>
<span id="more"></span>
<h2 id="Player-Prefs"><a href="#Player-Prefs" class="headerlink" title="Player Prefs"></a>Player Prefs</h2><p>Player Prefs是unity引擎内建的主要用来存储玩家偏好设定的一个类，也是用于存储小型游戏数据和偏好设置的简单键值对存储方式。它将数据存储在本地设备上，通常用于保存玩家的设置、解锁状态、得分等小型数据。<br>Player Prefs使用的是类似字典的存储方式，玩家进行数据存储时，需要输入一个key参数以及一个value参数；获取数据时只要输入键就可以获取到对应的值了。Player Prefs形式存储的数据保存在当前开发平台的注册表中，详细位置可以查看官方文档。</p>
<h3 id="数据存储和读取"><a href="#数据存储和读取" class="headerlink" title="数据存储和读取"></a>数据存储和读取</h3><p>数据存储函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetString</span>(<span class="params"><span class="built_in">string</span> Key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetInt</span>(<span class="params"><span class="built_in">string</span> Key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetFloat</span>(<span class="params"><span class="built_in">string</span> Key, <span class="built_in">float</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="comment">//示例:PlayerPrefs.SetString(&quot;PlayerName&quot;, playerName);</span></span><br></pre></td></tr></table></figure>

<p>设置完后需要保存PlayerPrefs的状态：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PlayerPrefs.Save();</span><br></pre></td></tr></table></figure>

<p>数据读取函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">string</span> Key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">string</span> Key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">string</span> Key</span>)</span>;</span><br><span class="line"><span class="comment">//示例:string name = PlayerPrefs.GetString(&quot;PlayerName&quot;, &quot;Guest&quot;);</span></span><br><span class="line"><span class="comment">//第二个参数是默认值，如果指定的键不存在或不是string类型，则返回默认值</span></span><br></pre></td></tr></table></figure>

<h3 id="适用场景和特点"><a href="#适用场景和特点" class="headerlink" title="适用场景和特点"></a>适用场景和特点</h3><ul>
<li>适用场景： 适合保存游戏设置、解锁状态、用户首选项等小型数据。</li>
<li>优点： 简单易用，适用于少量数据，无需额外文件操作。</li>
<li>缺点：数据类型单一，安全性低。</li>
<li>拓展：JsonUtility<br>通过它我们可以将任何Unity序列化程序支持的类转成Json对象，而Json就是一个按一定格式书写的字符串，这样我们就可以使用PlayerPrefs.SetString()函数来存储Json字符串了</li>
</ul>
<h2 id="JSON存储"><a href="#JSON存储" class="headerlink" title="JSON存储"></a>JSON存储</h2><p>JSON是一种轻量级的数据交换格式，支持多种主流编程语言，JSON数据可以轻松地在多种不同的语言之间进行转换，适用于保存和加载游戏状态、配置文件、角色属性等复杂的数据结构。而在本质上，JSON是将数据按一定规则和格式书写的文本文件。<br>以下是在Unity中使用JSON进行数据存储和读取的一般步骤：</p>
<h3 id="序列化对象到JSON"><a href="#序列化对象到JSON" class="headerlink" title="序列化对象到JSON"></a>序列化对象到JSON</h3><p>首先，你需要将游戏数据对象转换为JSON格式，以便将其保存到文件或PlayerPrefs中。Unity提供了JsonUtility类来实现这一目的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个数据结构</span></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> playerName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> playerScore;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isPlayerAlive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数据对象</span></span><br><span class="line">PlayerData playerData = <span class="keyword">new</span> PlayerData();</span><br><span class="line">playerData.playerName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">playerData.playerScore = <span class="number">1000</span>;</span><br><span class="line">playerData.isPlayerAlive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据对象转换为JSON字符串</span></span><br><span class="line"><span class="built_in">string</span> jsonData = JsonUtility.ToJson(playerData);</span><br></pre></td></tr></table></figure>

<h3 id="保存JSON数据"><a href="#保存JSON数据" class="headerlink" title="保存JSON数据"></a>保存JSON数据</h3><p>接下来，你可以将生成的JSON字符串保存到文件或PlayerPrefs中。如果要保存到文件，你可以使用C#的文件操作方法。<br>如果要将JSON保存到PlayerPrefs中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存JSON字符串到PlayerPrefs</span></span><br><span class="line">PlayerPrefs.SetString(<span class="string">&quot;PlayerData&quot;</span>, jsonData);</span><br><span class="line">PlayerPrefs.Save(); <span class="comment">// 确保数据已保存</span></span><br></pre></td></tr></table></figure>

<p>如果要将JSON保存到文件中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"><span class="built_in">string</span> saveFileName, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> json = JsonUtility.ToJson(data);</span><br><span class="line">    <span class="comment">//Application.persistentDataPath是unity提供的存储永久化数据的路径，随着发布平台的不同而自动变更</span></span><br><span class="line">    <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line">    File.WriteAllText(path, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取JSON数据"><a href="#读取JSON数据" class="headerlink" title="读取JSON数据"></a>读取JSON数据</h3><p>当需要读取数据时，你可以从文件或PlayerPrefs中检索JSON字符串，然后将其转换回游戏数据对象。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件中读取JSON字符串</span></span><br><span class="line"><span class="built_in">string</span> jsonData = File.ReadAllText(<span class="string">&quot;playerData.json&quot;</span>);</span><br><span class="line"><span class="comment">// 或者从PlayerPrefs中读取JSON字符串</span></span><br><span class="line"><span class="built_in">string</span> jsonData = PlayerPrefs.GetString(<span class="string">&quot;PlayerData&quot;</span>);</span><br><span class="line"><span class="comment">// 将JSON字符串转换为数据对象</span></span><br><span class="line">PlayerData loadedData = JsonUtility.FromJson&lt;PlayerData&gt;(jsonData);</span><br></pre></td></tr></table></figure>

<h3 id="JSON适用场景和特点"><a href="#JSON适用场景和特点" class="headerlink" title="JSON适用场景和特点"></a>JSON适用场景和特点</h3><ul>
<li>优点：<br>相对来说更方便人类阅读和编写；<br>适用范围广泛，支持多种主流编程语言；<br>轻量级，易于网络传输与机器解析和生成；</li>
<li>缺点：<br>支持的数据类型有限；<br>数据安全性低；</li>
<li>适用范围：<br>联网：优秀的网络数据交换载体、云存档；<br>本地存储：非敏感而需要大量读取和修改的数据，玩家的偏好设置等。</li>
</ul>
<h3 id="ToJson详解"><a href="#ToJson详解" class="headerlink" title="ToJson详解"></a>ToJson详解</h3><p>对于ToJson函数，我们需要做一些补充了解。ToJson(object obj, bool x)函数会尝试序列化我们传入到第一个参数的对象里面的可序列化数据（第二个参数代表是否将json数据转换成符合阅读习惯的格式），而不是序列化我们传入的这个参数本身，所以传入的参数为一个data实例就行，结构体和类都可以直接序列化（将类标记为[System.Serializable]）。<br>但ToJson的第一个参数object并不能接收所有类型，如果你传入的参数，或者这个参数所包含的数据中，有一些对象是Unity序列化程序所不支持的，那么这些对象就会被忽略。</p>
<p>那么Unity序列化程序支持哪些类型的对象呢？</p>
<ul>
<li>整数和浮点数：包括int、float、double等。</li>
<li>布尔值：bool类型。</li>
<li>字符串：string类型。</li>
<li>枚举：枚举类型，如enum。</li>
<li>结构体：用户自定义的结构体。</li>
<li>数组：数组类型，如int[]、string[]等。</li>
<li>表和集合：一些集合类型，如<code>List&lt;T&gt;</code>、<code>Dictionary&lt;K, V&gt;</code>等。</li>
<li>Unity内置类型： Unity的Vector2、Vector3、Quaternion、Color等类型。</li>
<li>自定义类和对象：你可以自定义类，并使用[Serializable]属性来标记它们以进行序列化。</li>
<li>接口：接口可以在Unity中被序列化，但只有具体实现的类的实例可以被正确序列化。</li>
<li>GameObject和Component： Unity中的GameObject和Component也可以被序列化，但需要注意它们的序列化与持久性存储有关，如Prefab和Scene。</li>
<li>序列化嵌套对象： 你可以嵌套序列化对象，即一个序列化对象中包含另一个序列化对象。</li>
</ul>
<p>Unity的序列化系统在序列化和反序列化对象时具有一些限制和规则，包括：</p>
<ul>
<li>字段访问级别：只有public的字段可以被Unity的序列化系统正确序列化和反序列化。这些字段通常是被标记为 [Serializable] 特性的字段。</li>
<li>字段类型限制：Unity的序列化系统支持一系列常见的数据类型，如整数、浮点数、字符串、布尔值、枚举、结构体等。对于更复杂的数据类型，如字典、多维数组、泛型、委托等，通常需要进行转换或者使用其他方法来实现序列化和反序列化。</li>
<li>MonoBehaviour序列化：Unity的MonoBehaviour脚本中的字段，即使是私有字段，也可以被Unity序列化系统正确序列化和在Inspector中编辑，因为MonoBehaviour继承了Unity的序列化接口。</li>
<li>非静态字段：非静态字段可以被序列化，但静态字段通常不会被序列化。</li>
<li>只读和常量字段：只读和常量字段不能被序列化，因为它们的值不能被更改。</li>
<li>嵌套对象：Unity支持嵌套对象的序列化，允许你在一个序列化对象中包含其他序列化对象。</li>
</ul>
<p>如果需要在Unity中存储不支持序列化的数据类型，你通常需要将其转换成支持Unity序列化的类型，或者手动将其数据转换成一种支持的数据结构。对于字典、泛型集合等复杂数据结构，你可能需要编写自定义的序列化和反序列化逻辑。Unity的JsonUtility等工具可以帮助你将数据转换成JSON格式以进行存储和加载。</p>
<p>怎样快速知道一个类型的数据能否被序列化存储？</p>
<p>将这些数据标记为公有，或添加[Serializable]属性，能在Inspector窗口观察到，就说明可以进行序列化存储。</p>
<h2 id="Binary-Serialization"><a href="#Binary-Serialization" class="headerlink" title="Binary Serialization"></a>Binary Serialization</h2><p>声明：二进制序列化有重大风险，不建议将其用于数据处理，谨慎使用，详情见<br><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/serialization/binaryformatter-security-guide">使用 BinaryFormatter 和相关类型时的反序列化风险</a>。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>在Unity中使用XML序列化和反序列化需要使用System.Xml.Serialization命名空间提供的类。下面是使用XML序列化的基本步骤：</p>
<h3 id="创建可序列化的数据类"><a href="#创建可序列化的数据类" class="headerlink" title="创建可序列化的数据类"></a>创建可序列化的数据类</h3><p>首先，你需要创建一个用于存储数据的类，该类需要被标记为 [System.Serializable] 特性，并包含公共字段或属性以保存数据。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> playerName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> playerScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化数据到XML"><a href="#序列化数据到XML" class="headerlink" title="序列化数据到XML"></a>序列化数据到XML</h3><p>使用XmlSerializer类将数据对象序列化为XML格式，需要提供一个FileStream或TextWriter来将XML数据写入文件或其他数据源。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Xml;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SerializeToXML</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    PlayerData player = <span class="keyword">new</span> PlayerData();</span><br><span class="line">    player.playerName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">    player.playerScore = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    XmlSerializer serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(PlayerData));</span><br><span class="line">    <span class="keyword">using</span> (FileStream stream = <span class="keyword">new</span> FileStream(<span class="string">&quot;playerData.xml&quot;</span>, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        serializer.Serialize(stream, player);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化数据"><a href="#反序列化数据" class="headerlink" title="反序列化数据"></a>反序列化数据</h3><p>若要读取和还原XML数据，可以使用相同的XmlSerializer类将XML数据反序列化为对象。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PlayerData <span class="title">DeserializeFromXML</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    XmlSerializer serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(PlayerData));</span><br><span class="line">    <span class="keyword">using</span> (FileStream stream = <span class="keyword">new</span> FileStream(<span class="string">&quot;playerData.xml&quot;</span>, FileMode.Open))</span><br><span class="line">    &#123;</span><br><span class="line">        PlayerData player = (PlayerData)serializer.Deserialize(stream);</span><br><span class="line">        <span class="keyword">return</span> player;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：<br>确保你的数据类和字段&#x2F;属性都被标记为 [System.Serializable]。XmlSerializer使用属性访问来序列化和反序列化数据，因此需要使用公共字段或属性。要保存和加载XML数据，需要使用文件操作或其他数据源。在示例中，我们使用了FileStream来保存和加载XML文件。</p>
</blockquote>
<p>XML序列化是一种强大的数据存储和交换方式，可用于保存和加载游戏状态、配置文件和其他复杂的数据结构。但需要注意，XML文件通常相对较大，因此在性能和存储空间方面要有所考虑。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Unity生命周期</title>
    <url>/2023/10/25/Unity/%E6%B5%85%E8%B0%88Unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>Unity 的生命周期指的是游戏对象和组件在其整个生命周期内经历的不同阶段和事件。这些生命周期事件会在特定时刻触发，让你可以在不同的时机执行代码，来控制游戏对象和组件的行为。在使用 Unity 引擎开发之前，一定要先了解它脚本的生命周期。这篇文章我们就对 Unity 的生命周期中重要的事件函数来进行一些讲解。</p>
<span id="more"></span>
<h2 id="编译期生命周期"><a href="#编译期生命周期" class="headerlink" title="编译期生命周期"></a>编译期生命周期</h2><h3 id="Reset-初始化"><a href="#Reset-初始化" class="headerlink" title="Reset() 初始化"></a>Reset() 初始化</h3><p>Reset()重置函数：Reset函数是一种特殊的编辑器脚本函数，用于自定义Unity编辑器中的组件的默认属性值和行为。当你在脚本中实现Reset函数时，它将在以下情况下自动调用：</p>
<ul>
<li>当你将脚本组件拖拽到Unity编辑器的组件面板上时。</li>
</ul>
<blockquote>
<p>如果在运行期间动态将脚本挂到一个游戏对象上，这个函数也不会执行。</p>
</blockquote>
<h3 id="OnDrawGizmos-更新"><a href="#OnDrawGizmos-更新" class="headerlink" title="OnDrawGizmos() 更新"></a>OnDrawGizmos() 更新</h3><p>OnDrawGizmos()函数：OnDrawGizmos函数是Unity中的一个特殊编辑器脚本函数，用于在场景视图中绘制可视化的辅助信息和标记，这些可视化元素通常用于帮助开发人员调试和可视化游戏对象的状态和行为。这个函数在编辑期间和在运行期间调用频率不同。</p>
<ul>
<li>编译期间：OnDrawGizmos 函数在Unity编辑器中运行时频繁调用，用于在场景视图中绘制可视化辅助信息。这使得开发人员能够实时查看游戏对象的可视化状态和调试信息，以便更好地理解游戏场景。在编辑器中进行场景构建和调试时，这些可视化元素对于快速迭代和问题排查非常有用。<br>它不是每帧执行，而是只在 <strong>Scene</strong> 视图打开的时候，在这个视图下进行任何操作时都会调用这个函数，包括运行时也会调用。如果不在Scene视图下，就算进行操作也不会调用这个函数。</li>
</ul>
<h2 id="运行期生命周期"><a href="#运行期生命周期" class="headerlink" title="运行期生命周期"></a>运行期生命周期</h2><p>我们先来看这样一张图（官方手册2023.3版本）：<br><img src="/../../images/pic4/monobehaviour_flowchart.svg" alt="Unity生命周期"></p>
<h3 id="Awake"><a href="#Awake" class="headerlink" title="Awake()"></a>Awake()</h3><p>Awake 是 Unity MonoBehaviour 脚本中的一个特殊函数，用于初始化对象的状态、引用和配置，以准备好在游戏运行时执行。这是一个常用于设置变量、引用其他组件、加载资源等的地方。<br>它在游戏对象<strong>首次被实例化后立即调用</strong>，<strong>整个脚本生命周期只执行一次</strong>。注意，如果游戏对象开始运行时未激活，Awake也不会执行，直到游戏对象第一次被激活。如果游戏对象开始运行时就已经激活，那么无论这个脚本是否启用了，Awake都会执行。</p>
<h3 id="OnEnable"><a href="#OnEnable" class="headerlink" title="OnEnable()"></a>OnEnable()</h3><p>OnEnable 通常用于在脚本组件激活时进行初始化、订阅事件、或执行其他操作。<br>OnEnable 与 OnDisable() 配套结合，当<strong>脚本启用</strong>（注意，游戏对象激活时会去调用被启用的脚本，OnEnable会执行；不改变游戏对象，只启用脚本时OnEnable也会执行）的时候触发，<strong>运行期间可以执行多次</strong>。只有挂载的游戏对象和脚本都激活时，这个方法才会被调用。</p>
<h3 id="OnApplicationPause-bool-pause"><a href="#OnApplicationPause-bool-pause" class="headerlink" title="OnApplicationPause(bool pause)"></a>OnApplicationPause(bool pause)</h3><p>OnApplicationPause 是一个Unity中的特殊生命周期函数，用于处理<strong>应用程序暂停和恢复时的事件</strong>。这个函数在MonoBehaviour脚本中使用，主要用于移动平台（如iOS和Android）上的应用程序，以处理应用程序暂停和恢复时的逻辑。当你切换后台，打开别的软件时，这个函数会自动调用，并且将 “pause” 修改为 “true”，当你再切回来的时候这个函数又自动调用，并将 “pause” 修改为 “false”，<strong>在脚本的生命周期可以执行多次</strong>。</p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h3><p>Start 在 Awake 和 OnEnable 之后执行，用于执行一次性的初始化操作，一般用于给脚本字段初始值。但需要注意，Start 函数只会在脚本所附着的游戏对象首次进入游戏时执行，<strong>整个脚本的生命周期只执行一次</strong>。只有挂载的游戏对象和脚本都激活时，这个方法才会被调用。</p>
<p>以上几个函数，当游戏开始运行时，如果游戏对象和脚本都是启动的，那么执行顺序如图所示：<br><img src="/../../images/pic4/seq.png" alt="启动时函数的执行顺序"></p>
<h3 id="FixedUpdate-物理更新"><a href="#FixedUpdate-物理更新" class="headerlink" title="FixedUpdate() 物理更新"></a>FixedUpdate() 物理更新</h3><p>FixedUpdate 是Unity中的一个特殊生命周期函数，用于<strong>处理物理更新和固定时间间隔的逻辑</strong>。例如给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧。(两者帧长不同)。FixedUpdate 函数<strong>在每秒之间以固定的时间间隔执行</strong>。这个时间间隔由Unity的物理时间步长决定，通常为每秒50次（默认情况下），但可以根据项目设置进行调整。</p>
<ul>
<li><p>实际帧率低于固定帧率：例如固定帧率设置为60帧每秒，实际帧率为30帧每秒，Unity仍然会以固定帧率的频率调用 FixedUpdate()。物理模拟仍然以固定时间步骤的频率进行更新，与 FixedUpdate() 同步。但游戏渲染帧可能会跳过一些帧，以匹配实际帧率，<strong>相当于一次渲染帧之间可能进行了多次物理计算</strong>。</p>
</li>
<li><p>实际帧率高于固定帧率：例如固定帧率设置为30帧每秒，实际帧率为60帧每秒，如果实际帧率高于固定帧率，那么 FixedUpdate() 将仍然以固定时间步骤频率调用，但在两次调用之间可能有额外的帧渲染。这可能导致<strong>多次帧渲染之间没有物理更新</strong>，因为 <strong>FixedUpdate() 是按固定频率进行调用的</strong>，<strong>相当于多次渲染帧之间可能只进行了一次物理计算</strong>。</p>
</li>
</ul>
<blockquote>
<p>固定帧率（Fixed Frame Rate）是你在Unity项目设置中指定的每秒渲染多少次。这是一个目标帧率，Unity将尝试以这个帧率来渲染画面和执行物理计算。<br>实际帧率（Actual Frame Rate）是实际情况下你的应用程序每秒渲染的帧数，通常是由计算机性能、场景复杂性等因素决定的。</p>
</blockquote>
<h3 id="Update-逻辑更新"><a href="#Update-逻辑更新" class="headerlink" title="Update() 逻辑更新"></a>Update() 逻辑更新</h3><p>Update() 函数在每一帧渲染之前都会被调用，这意味着它的调用频率与实际帧率一致，执行的频率不固定，取决于计算机性能等因素。通常用于处理用户输入、游戏逻辑和交互，可以在这个函数中编写代码来响应玩家的操作，移动游戏角色，检测碰撞，更新游戏状态等。</p>
<h3 id="LateUpdate-逻辑后更新"><a href="#LateUpdate-逻辑后更新" class="headerlink" title="LateUpdate() 逻辑后更新"></a>LateUpdate() 逻辑后更新</h3><p>LateUpdate() 函数在每一帧的最后被调用，它是在 Update() 和物理更新函数（如 FixedUpdate()）之后执行的。这意味着在 LateUpdate() 中的逻辑会在其他更新逻辑之后执行，通常在渲染之前。LateUpdate() 主要用于处理与其他游戏对象、相机和渲染相关的逻辑。它通常用于摄像机跟随、玩家控制、相机视野调整以及其他可能受到游戏对象位置和状态影响的操作。<br>许多相机操作通常在 LateUpdate() 中执行，以确保相机位置和视野在渲染之前正确更新，包括摄像机跟随、插值相机位置、处理相机震动效果等。<br>如果你的逻辑需要考虑其他游戏对象的位置和状态，或者需要与相机有关的操作，那么 LateUpdate() 可能更适合这些情况。</p>
<blockquote>
<p>对于一个相机跟随角色脚本，相机的操作应该放在什么函数里呢？<br>应该放在 LateUpdate() 函数里，因为相机的状态与角色的状态相关，如果放在 Update() 函数里，可能出现角色状态还没有更新，相机位置就已经更新了的情况，而在 LateUpdate() 中执行相机操作可以确保它们基于其他对象的最新位置和状态。<br>但如果相机状态与其他游戏对象没有关系，那么放在 Update() 函数里也可以。</p>
</blockquote>
<h3 id="OnWillRenderObject-场景渲染"><a href="#OnWillRenderObject-场景渲染" class="headerlink" title="OnWillRenderObject() 场景渲染"></a>OnWillRenderObject() 场景渲染</h3><p>OnWillRenderObject() 函数在相机渲染某个可见物体时被调用。这个函数通常用于处理物体在相机视图中的可见性以及与相机有关的操作。如果对象可见，每个照相机调用一次，通常是在物体的渲染帧之前。对于一些确定要渲染的对象，可以在正式渲染前再做一些特殊处理，比如裁剪，材质重置等。</p>
<h3 id="OnDrawGizmos-线框渲染"><a href="#OnDrawGizmos-线框渲染" class="headerlink" title="OnDrawGizmos() 线框渲染"></a>OnDrawGizmos() 线框渲染</h3><p>在 Scene 视图打开的时候每一帧进行更新，和在编辑器模式下调用的频率不同。</p>
<h3 id="OnGUI-图形绘制"><a href="#OnGUI-图形绘制" class="headerlink" title="OnGUI() 图形绘制"></a>OnGUI() 图形绘制</h3><p>OnGUI() 函数在渲染和处理GUI事件时调用，用于处理游戏的图形用户界面，这个函数通常用于在游戏屏幕上绘制各种用户界面元素，如按钮、标签、文本框等。OnGUI() 函数在每一帧渲染之后调用，用于绘制游戏界面。它是在 Update() 和 LateUpdate() 后执行的，通常在渲染帧之后。<br>OnGUI() 通常与其他更新函数（如 Update()、LateUpdate()）一起使用，以便根据游戏逻辑更新用户界面。你可以在这些函数中设置用户界面的状态，然后在 OnGUI() 中将其绘制出来。如果Monobehaviour的enabled属性设为false，OnGUI()将不会被调用。<br>一般情况下，它在每一帧中只会执行一次。然而，有一些特殊情况下，OnGUI() 可能会被调用多次。例如，如果你使用GUI布局系统中的 Repaint() 函数来强制重新绘制界面，或者在特定事件中触发了GUI的刷新，这可能导致 OnGUI() 被多次调用。但这些情况属于特殊情况，不是每一帧都会发生的情况。</p>
<h3 id="OnApplicationQuit-函数"><a href="#OnApplicationQuit-函数" class="headerlink" title="OnApplicationQuit() 函数"></a>OnApplicationQuit() 函数</h3><p>OnApplicationQuit() 函数用于在应用程序即将退出时执行一些清理和处理操作。它会在用户关闭游戏或应用程序时调用。通常，你可以在这个函数中执行例如保存游戏状态、释放资源、关闭网络连接等必要的清理工作。如果你的应用程序有多个场景，该函数将在退出当前场景时触发，而不是在整个应用程序退出时触发。</p>
<blockquote>
<p>注意，Unity 仅在正常退出时（用户手动关闭应用程序）才会调用 OnApplicationQuit()。如果应用程序因为崩溃或其他异常情况而关闭，该函数可能不会被触发。</p>
</blockquote>
<h3 id="OnDisable-禁用函数"><a href="#OnDisable-禁用函数" class="headerlink" title="OnDisable() 禁用函数"></a>OnDisable() 禁用函数</h3><p>OnDisable() 函数用于处理脚本被禁用时的逻辑。当你在 Unity 编辑器中手动禁用脚本组件，或者通过代码设置脚本的 enabled 属性为 false 时，OnDisable() 函数将被调用。<br>OnDisable() 主要用于执行脚本组件在被禁用时的清理操作。这可以包括停止协程、释放资源、取消事件订阅等。它通常用于确保脚本在被禁用时不会继续执行不必要的逻辑。</p>
<h3 id="OnDestory-销毁函数"><a href="#OnDestory-销毁函数" class="headerlink" title="OnDestory() 销毁函数"></a>OnDestory() 销毁函数</h3><p>OnDestroy() 函数用于处理游戏对象或脚本组件的销毁逻辑。当游戏对象被销毁时，或者脚本组件从游戏对象上移除时，OnDestroy() 函数将被调用。<br>销毁游戏对象通常发生在场景切换、关卡结束或手动销毁游戏对象时。OnDestroy() 主要用于执行在游戏对象销毁前的清理操作。这可以包括释放资源、取消事件订阅、清理协程等。它用于确保游戏对象或脚本在被销毁时不会留下不必要的遗留物。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode1155.掷骰子等于目标和的方法数</title>
    <url>/2023/10/21/LeetCode/LeetCode1155.%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%92%8C%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode1155.掷骰子等于目标和的方法数【medium】。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>这里有 n 个一样的骰子，每个骰子上都有 k 个面，分别标号为 1 到 k 。</p>
<p>给定三个整数 n ,  k 和 target ，返回可能的方式(从总共 kn 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 target 。</p>
<p>答案可能很大，你需要对 109 + 7 取模 。</p>
<h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p>示例 1：<br>输入：n &#x3D; 1, k &#x3D; 6, target &#x3D; 3<br>输出：1<br>解释：你扔一个有 6 个面的骰子。<br>得到 3 的和只有一种方法。</p>
<p>示例 2：<br>输入：n &#x3D; 2, k &#x3D; 6, target &#x3D; 7<br>输出：6<br>解释：你扔两个骰子，每个骰子有 6 个面。<br>得到 7 的和有 6 种方法：1+6 2+5 3+4 4+3 5+2 6+1。</p>
<p>示例 3：<br>输入：n &#x3D; 30, k &#x3D; 30, target &#x3D; 500<br>输出：222616187<br>解释：返回的结果必须是对 109 + 7 取模。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; n, k &lt;&#x3D; 30</li>
<li>1 &lt;&#x3D; target &lt;&#x3D; 1000</li>
</ul>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>①扔n个骰子，或者说等效于一个骰子扔n次，求得到某个固定骰子和的方案次数，为了让结果是一个固定的和，每一个骰子的点数，都对后续骰子的点数有影响。之前的状态影响当前的状态，之后的状态取决于当前的状态，且是求满足次数，也能把状态划分为多个小步骤（扔一次骰子，扔两次骰子……），第一时间应该考虑尝试动态规划解法；<br>②<strong>进行状态定义</strong>：明确变量，扔了i个骰子，和为j，我们用<code>f(i, j)</code>表示扔了i个骰子时和为j的方案次数，那么我们的目的就是求<code>f(n, target)</code>；<br>③<strong>分析状态转移方程</strong>：扔了i个骰子和为j，对于第i个骰子，可能的取值范围是1~k，那么<code>f(i, j) = f(i - 1, j - 1) + f(i - 1, j - 2) …… + f(i - 1, j - k)</code>, 即<code>∑f(i − 1, j − x), x∈[1, k]</code>；<br>④<strong>确立边界条件</strong>：<code>f(0, 0) = 1</code>，且f(i, j) &#x3D; 0当j &lt; i(骰子点数至少是1)</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>C#</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NumRollsToTarget</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">int</span> k, <span class="built_in">int</span> target</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//f(i, j)表示使用了i个骰子时和为j的方案数目</span></span><br><span class="line">    <span class="built_in">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; target + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">1</span>; x &lt;= k; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= x) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - x]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode117.填充每个节点的下一个右侧节点指针 II</title>
    <url>/2023/11/03/LeetCode/LeetCode117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II/</url>
    <content><![CDATA[<p>LeetCode117.填充每个节点的下一个右侧节点指针 II【medium】。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">  <span class="built_in">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。<br>初始状态下，所有 next 指针都被设置为 NULL 。</p>
<h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p>示例 1：<br><img src="/../../images/pic6/117_sample.png" alt="117示例"><br>输入：root &#x3D; [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。</p>
<p>示例 2：<br>输入：root &#x3D; []<br>输出：[]</p>
<blockquote>
<p>提示：</p>
<ul>
<li>树中的节点数在范围 [0, 6000] 内</li>
<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>
</ul>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="方法一：层序遍历"><a href="#方法一：层序遍历" class="headerlink" title="方法一：层序遍历"></a>方法一：层序遍历</h3><p>由图示可知，每一个节点的 next 指的就是和节点处于同一层的下一个节点，我们很容易想到二叉树的层序遍历。二叉树常规的层序遍历方式是使用一个 Queue，首先把二叉树的根节点入队，然后当队列数目不为空时，将队头元素出队，然后将出队元素的左右孩子入队（如果存在的话），直到 Queue 数目为0结束循环。<br>但依照题意，我们想要的是将某一层的节点全部相连，而普通层序遍历时，Queue 中的元素某一时刻并不一定是同一层的，所以我们可以在层序遍历的基础上稍微进行一些修改，找到属于同一层的所有节点。具体的方式就是在一次 while 循环开启的时候，记录下当前 Queue 中的数目元素 n，然后通过 for 循环进行 n 次出队操作，这样就能保证每一次循环出队列的元素都是同一层的，while 结束后的 Queue 元素都是下一层的。</p>
<h3 id="方法二：使用已建立的-next-指针"><a href="#方法二：使用已建立的-next-指针" class="headerlink" title="方法二：使用已建立的 next 指针"></a>方法二：使用已建立的 next 指针</h3><p>方法一使用了层序遍历，需要额外的空间。由于必须遍历所有节点，所以无法降低时间复杂度，但可以考虑如何降低空间复杂度。我们由题意可以知道，当我们遍历某一层节点时，由于我们已知每一个节点的 left 和 right，所以其实对于下一层的构造，我们也可以确定。对于每一层，只要知道最左边的节点，就可以遍历该层了。所以从根节点开始，我们可以建立下一层的 next，然后遍历下一层，再建立下下层的 next，以此类推，就不需要使用额外空间了。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题解一：层序遍历"><a href="#题解一：层序遍历" class="headerlink" title="题解一：层序遍历"></a>题解一：层序遍历</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">public class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Connect</span>(<span class="params">Node root</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">        Node last = <span class="literal">null</span>; <span class="comment">//last代表上一次访问的节点</span></span><br><span class="line">        queue.Enqueue(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.Count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            last = <span class="literal">null</span>; <span class="comment">//每一层和上一层无需串联，对于每一层的循环，需要把last置空</span></span><br><span class="line">            <span class="built_in">int</span> n = queue.Count; <span class="comment">//n不能在循环里获取，因为count数目会发生变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                Node temp = queue.Dequeue();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.Enqueue(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.Enqueue(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前节点不是首节点，那么就将当前节点作为上一次节点的next</span></span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">1</span>) &#123;</span><br><span class="line">                    last.next = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                last = temp; <span class="comment">//更新last节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解二：使用已建立的-next-指针"><a href="#题解二：使用已建立的-next-指针" class="headerlink" title="题解二：使用已建立的 next 指针"></a>题解二：使用已建立的 next 指针</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">public class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    Node last = <span class="literal">null</span>, nextStart = <span class="literal">null</span>; <span class="comment">//last代表上一次访问的节点，nextStart代表下一层开始的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Connect</span>(<span class="params">Node root</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root; <span class="comment">//start代表本层开始的节点</span></span><br><span class="line">        <span class="keyword">while</span>(start != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node temp = start; <span class="comment">//temp代表当前遍历到的节点</span></span><br><span class="line">            last = <span class="literal">null</span>; <span class="comment">// 对于每次循环，都要置空last和nextStart</span></span><br><span class="line">            nextStart = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//根据当前节点的left和right建立next连接</span></span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Handle(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Handle(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.next; <span class="comment">//更新temp节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart; <span class="comment">//遍历完当前层后更新start</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">Node p</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 上一次节点不为空，说明本层有前边的节点，将p设为last的next</span></span><br><span class="line">        <span class="keyword">if</span>(last != <span class="literal">null</span>) &#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nextstart为空，说明某次循环刚开始，p是某一层的首节点</span></span><br><span class="line">        <span class="keyword">if</span>(nextStart == <span class="literal">null</span>) &#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p; <span class="comment">//更新last</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode1402.做菜顺序</title>
    <url>/2023/10/21/LeetCode/LeetCode1402.%E5%81%9A%E8%8F%9C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>LeetCode1402.做菜顺序【hard】。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个厨师收集了他 n 道菜的满意程度 satisfaction ，这个厨师做出每道菜的时间都是 1 单位时间。</p>
<p>一道菜的 「 like-time 系数 」定义为烹饪这道菜结束的时间（包含之前每道菜所花费的时间）乘以这道菜的满意程度，也就是 time[i]*satisfaction[i] 。</p>
<p>返回厨师在准备了一定数量的菜肴后可以获得的最大 like-time 系数总和。</p>
<p>你可以<strong>任意</strong>顺序安排做菜的顺序，你也可以选择<strong>放弃</strong>做某些菜来获得更大的总和。</p>
<h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p>示例 1：<br>输入：satisfaction &#x3D; [-1,-8,0,5,-9]<br>输出：14<br>解释：去掉第二道和最后一道菜，最大的 like-time 系数和为 (-1<em>1 + 0</em>2 + 5*3 &#x3D; 14) 。每道菜都需要花费 1 单位时间完成。</p>
<p>示例 2：<br>输入：satisfaction &#x3D; [4,3,2]<br>输出：20<br>解释：可以按照任意顺序做菜 (2<em>1 + 3</em>2 + 4*3 &#x3D; 20)</p>
<p>示例 3：<br>输入：satisfaction &#x3D; [-1,-4,-5]<br>输出：0<br>解释：大家都不喜欢这些菜，所以不做任何菜就可以获得最大的 like-time 系数。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>n &#x3D;&#x3D; satisfaction.length</li>
<li>1 &lt;&#x3D; n &lt;&#x3D; 500</li>
<li>-1000 &lt;&#x3D; satisfaction[i] &lt;&#x3D; 1000</li>
</ul>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>①想要得到最大like-time系数总和，要满足以下几个原则：</p>
<ul>
<li>满意度为负数的菜尽量不做；</li>
<li>为了让满意度为正数的菜获得更多 like-time 系数，可能要适当地做一些满意度为负数的菜；</li>
<li>满意度越高的菜越要晚做。</li>
</ul>
<p>②为了满足以上原则，首先必要对数组进行排序，满意度越大的菜越往后排；<br>③每一次的决策都依赖于当前状态，都影响着后续状态，是很经典的动态规划问题（此处暂不讲解动态规划概念）；<br>④<strong>进行状态定义</strong>：明确变量，第x次对第y道菜做出决策，对于每道菜可以选或不选，此时可以转化为 [0 - 1 背包] 问题；用i代表对第i道菜抉择，j代表进行第j次决策，用<code>dp[i][j]</code>代表在前i道菜中进行了j次选择，即在前i道菜中选择了j道时的最大 like-time 系数总和；<br>⑤<strong>分析状态转移方程</strong>：前i道菜中选择了j道菜时，有两种情况。第i道菜在第j次选择时被选择了，第i道菜在第j次选择时没有被选择。</p>
<ul>
<li>第i道菜在第j次选择时被选择了，意味着在前i-1道菜中选择了j-1道菜，同时加上第i道菜的like-time系数，即<code>j * satisfaction[i-1]</code>（满意度数组下标从0开始）。可得公式<code>dp[i][j] = dp[i-1][j-1] + j * satisfaction[i-1]</code>。</li>
<li>第i道菜在第j次选择时没有被选择，意味着第j次选择发生在前i-1道菜之间，即在前i-1道菜中选择了j道，并且 i-1 &gt;&#x3D; j ，即 i &gt; j。可得公式<code>dp[i][j] = dp[i-1][j], i &gt; j</code>。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题解一：动态规划"><a href="#题解一：动态规划" class="headerlink" title="题解一：动态规划"></a>题解一：动态规划</h3><p>C#</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxSatisfaction</span>(<span class="params"><span class="built_in">int</span>[] satisfaction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> n = satisfaction.Length;</span><br><span class="line">    <span class="comment">//定义一个动态规划数组，dp[i][j]表示前i道菜中选择j道菜时可以得到的最大like-time总和</span></span><br><span class="line">    <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Array.Sort(satisfaction);</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + j * satisfaction[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; j) &#123;</span><br><span class="line">                dp[i][j] = Math.Max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.Max(res, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips：为什么定义的是<code>int[][] dp = new int[n + 1][]</code>而不是<code>int[][] dp = new int[n][]</code>，是一个小技巧，计算从索引1开始，避免在计算i-1或j-1时还要考虑索引小于0的情况。</p>
</blockquote>
<h3 id="题解二：前缀和"><a href="#题解二：前缀和" class="headerlink" title="题解二：前缀和"></a>题解二：前缀和</h3><p>一个很妙的解法，涉及到前缀和的解法。<br>知题解一分析，满意度越高的菜应该越晚做，同时兼做一些满意度为负的菜来增加时间系数。此处有一个简单的数学原理：<code>i * n</code>等于i + i……，n个i相加。我们在排序后，可以从满意度最高的菜开始考虑，这道菜每晚一轮做，相当于增加了一次这道菜的满意值，而n道菜每晚一轮做，相当于把这些菜的满意度都累加一遍。<br>此时，我们就可以利用一个值sum，来代表选择做这道菜时的收益，等于在此之后选择做的菜满意度累加值加上当前菜的满意度，如果大于0，说明选择做这道菜对于之后的选择来说收益为正，那么我们就可以选择做这道菜，由此可得解法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxSatisfaction</span>(<span class="params"><span class="built_in">int</span>[] satisfaction</span>)</span> &#123;</span><br><span class="line">    Array.Sort(satisfaction);</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = satisfaction.Length - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum += satisfaction[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode2558.从数量最多的堆取走礼物</title>
    <url>/2023/10/21/LeetCode/LeetCode2558.%20%E4%BB%8E%E6%95%B0%E9%87%8F%E6%9C%80%E5%A4%9A%E7%9A%84%E5%A0%86%E5%8F%96%E8%B5%B0%E7%A4%BC%E7%89%A9/</url>
    <content><![CDATA[<p>LeetCode2558. 从数量最多的堆取走礼物【easy】。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 gifts ，表示各堆礼物的数量。每一秒，你需要执行以下操作：</p>
<ul>
<li>选择礼物数量最多的那一堆。</li>
<li>如果不止一堆都符合礼物数量最多，从中选择任一堆即可。</li>
<li>选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。<br>返回在 k 秒后剩下的礼物数量。</li>
</ul>
<h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p>示例 1：<br>输入：gifts &#x3D; [25,64,9,4,100], k &#x3D; 4<br>输出：29<br>解释：<br>按下述方式取走礼物：</p>
<ul>
<li>在第一秒，选中最后一堆，剩下 10 个礼物。</li>
<li>接着第二秒选中第二堆礼物，剩下 8 个礼物。</li>
<li>然后选中第一堆礼物，剩下 5 个礼物。</li>
<li>最后，再次选中最后一堆礼物，剩下 3 个礼物。<br>最后剩下的礼物数量分别是 [5,8,9,4,3] ，所以，剩下礼物的总数量是 29 。</li>
</ul>
<p>示例 2：<br>输入：gifts &#x3D; [1,1,1,1], k &#x3D; 4<br>输出：4<br>解释：<br>在本例中，不管选中哪一堆礼物，都必须剩下 1 个礼物。<br>也就是说，你无法获取任一堆中的礼物。<br>所以，剩下礼物的总数量是 4 。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; gifts.length &lt;&#x3D; 10^3</li>
<li>1 &lt;&#x3D; gifts[i] &lt;&#x3D; 10^9</li>
<li>1 &lt;&#x3D; k &lt;&#x3D; 10^3</li>
</ul>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>①方法一很简单，每次对gifts数组进行排序，最后一位更新为取平方根后剩余的礼物数量，循环k次之后计算新gifts数组里元素之和。排序开销较大，属于以时间换空间的办法；<br>②方法二较方法一复杂一些，但也很容易想到。对于一堆礼物，我们每次需要找到数量最大的值，并且更新完这个值后又放回这堆礼物中，继续寻找下一个最大值，这明显可以通过维护一个最大堆来实现，根节点的值永远都是当前这堆礼物的最大值。最后，最大堆中所有礼物的数量之和就是我们要返回的答案。最大堆需要额外的空间开销，属于以空间换时间的方式。在C#中，可以直接使用PriorityQueue，因为优先队列有一个强大的特点：自动排序，可以非常简单的实现我们的需求。需要注意的是，<strong>PriorityQueue&lt;TElement,TPriority&gt;类出队列时，将删除优先级值最低的项，所以越大的值应该设一个越小的优先级值</strong>，我们可以使用该值的负数来作为优先级值。</p>
<blockquote>
<p>最大堆性质：结点的键值都小于等于其父结点的键值。<br>最小堆性质：结点的键值都大于等于其父结点的键值。<br>满足最大堆性质的二叉堆叫做最大堆，满足最小堆性质的二叉堆叫做最小堆。</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>方法一</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">PickGifts</span>(<span class="params"><span class="built_in">int</span>[] gifts, <span class="built_in">int</span> k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        Array.Sort(gifts);</span><br><span class="line">        gifts[gifts.Length - <span class="number">1</span>] = (<span class="built_in">int</span>)Math.Floor(Math.Sqrt(gifts[gifts.Length - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> gifts) &#123;</span><br><span class="line">        res += (<span class="built_in">long</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">PickGifts</span>(<span class="params"><span class="built_in">int</span>[] gifts, <span class="built_in">int</span> k</span>)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span> gift <span class="keyword">in</span> gifts) &#123;</span><br><span class="line">        pq.Enqueue(gift, -gift);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = pq.Dequeue();</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">        pq.Enqueue((<span class="built_in">int</span>)(Math.Floor(Math.Sqrt(x))), -(<span class="built_in">int</span>)(Math.Floor(Math.Sqrt(x))));</span><br><span class="line">        k --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pq.Count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += pq.Dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode2698.求一个整数的惩罚数</title>
    <url>/2023/10/22/LeetCode/LeetCode2698.%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode2698.求一个整数的惩罚数【medium】。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 n ，请你返回 n 的 惩罚数 。</p>
<p>n 的 惩罚数 定义为所有满足以下条件 i 的数的平方和：</p>
<p>1 &lt;&#x3D; i &lt;&#x3D; n<br>i * i 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 i 。</p>
<h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p>示例 1：<br>输入：n &#x3D; 10<br>输出：182<br>解释：总共有 3 个整数 i 满足要求：</p>
<ul>
<li>1 ，因为 1 * 1 &#x3D; 1</li>
<li>9 ，因为 9 * 9 &#x3D; 81 ，且 81 可以分割成 8 + 1 。</li>
<li>10 ，因为 10 * 10 &#x3D; 100 ，且 100 可以分割成 10 + 0 。<br>因此，10 的惩罚数为 1 + 81 + 100 &#x3D; 182</li>
</ul>
<p>示例 2：<br>输入：n &#x3D; 37<br>输出：1478<br>解释：总共有 4 个整数 i 满足要求：</p>
<ul>
<li>1 ，因为 1 * 1 &#x3D; 1</li>
<li>9 ，因为 9 * 9 &#x3D; 81 ，且 81 可以分割成 8 + 1 。</li>
<li>10 ，因为 10 * 10 &#x3D; 100 ，且 100 可以分割成 10 + 0 。</li>
<li>36 ，因为 36 * 36 &#x3D; 1296 ，且 1296 可以分割成 1 + 29 + 6 。<br>因此，37 的惩罚数为 1 + 81 + 100 + 1296 &#x3D; 1478</li>
</ul>
<blockquote>
<p>提示：<br>1 &lt;&#x3D; n &lt;&#x3D; 1000</p>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>①问题要求计算一个给定正整数n的惩罚数，其中惩罚数是由满足一定条件的数字的平方和组成的。这个条件是：将数字的平方表示为一个字符串，然后将这个字符串分割成<strong>若干连续子字符串</strong>，这些子字符串对应的整数值之和必须等于原数字。<br>②问题的关键在于对字符串s进行枚举分割，分割成s[0……i]s[i+1……j]，依次枚举剩下的子字符串，同时验证这种分割方案是否满足要求。依次考虑每一个字符，都有两种可能，一是逗号分割，构成新的子字符串，二是并入下一个字符串，由此得到一个树结构（以36的平方1296为例）：<br><img src="/../../images/pic3/pic1.jpg" alt="树状结构图"><br>对于解为树状结构的问题，我们很容易想到使用回溯法来解决。</p>
<blockquote>
<p><strong>回溯法</strong>：回溯算法是系统地搜索问题的解的方法。某个问题的所有可能解的称为问题的解空间，若解空间是有限的，则可将解空间映射成树结构。<br>任何解空间可以映射成树结构的问题，都可以使用回溯法。回溯法是能够在树结构里搜索到通往特定终点的一条或者多条特定路径。<br>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试，从而搜索到抵达特定终点的一条或者多条特定路径。<br>值得注意，回溯法以深度优先搜索的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</p>
</blockquote>
<p>③变量确立：我们使用一个DFS(int pos, int tot, int target, string s)函数来进行回溯，pos变量来代表当前的字符串索引，表示我们在字符串的哪个位置；tot是之前已经划分的子字符串之和；target代表目标值，我们要累积的数字之和必须等于 target；s是输入的数字字符串，代表一个数字的平方，例如 “81” 表示 9 * 9 的平方。<br>④边界条件确立：如果 pos 等于 s 的长度，这表示我们已经处理了整个字符串。在这种情况下，我们需要检查 tot 是否等于 target。<br>如果 tot 等于 target，说明我们已经成功地将字符串中的子字符串组合成满足条件的数，可以返回 true，否则返回 false。<br>⑤在每一步，我们都会尝试从当前位置 pos 开始<strong>创建一个新的子字符串</strong>，我们从 pos 开始向后遍历字符串 s。新构建的这个字符串的值用curSum来代表。<br>将当前字符添加到 curSum 中，将其从字符形式转换为整数，并更新 curSum。<br>如果 curSum + tot 大于 target，则跳出循环，因为这个子字符串无法继续累积得到满足条件的数。<br>否则，我们将继续递归调用 DFS 方法，将当前位置 i + 1 传递下去，同时更新 curSum + tot 作为累积值tot。<br>⑥如果在递归的过程中找到了一个组合，满足 tot 等于 target，则返回 true 表示成功。否则，在循环结束后返回 false 表示没有找到满足条件的组合。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>C#</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">DFS</span>(<span class="params"><span class="built_in">int</span> pos, <span class="built_in">int</span> tot, <span class="built_in">int</span> target, <span class="built_in">string</span> s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == s.Length) &#123;</span><br><span class="line">        <span class="keyword">return</span> tot == target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = pos; i &lt; s.Length; i++) &#123;</span><br><span class="line">        curSum = curSum * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(curSum + tot &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(DFS(i + <span class="number">1</span>, curSum + tot, target, s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">PunishmentNumber</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> s = (i * i).ToString();</span><br><span class="line">        <span class="keyword">if</span>(DFS(<span class="number">0</span>, <span class="number">0</span>, i, s)) &#123;</span><br><span class="line">            res += i * i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode274.H指数</title>
    <url>/2023/10/24/LeetCode/LeetCode274.H%E6%8C%87%E6%95%B0/</url>
    <content><![CDATA[<p>LeetCode274.H指数【medium】。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。</p>
<p>根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。</p>
<h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p>示例 1：<br>输入：citations &#x3D; [3,0,6,1,5]<br>输出：3<br>解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</p>
<p>示例 2：<br>输入：citations &#x3D; [1,3,1]<br>输出：1</p>
<blockquote>
<p>提示：</p>
<ul>
<li>n &#x3D;&#x3D; citations.length</li>
<li>1 &lt;&#x3D; n &lt;&#x3D; 5000</li>
<li>0 &lt;&#x3D; citations[i] &lt;&#x3D; 1000</li>
</ul>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>我们可以将初始数组进行排序，按引用次数升序排列，将h指数初始设置为0。对于这个排序后的数组，假设当前指数是h，如果citations[i] &gt; h，说明找到了一篇文章至少被引用了 h + 1 次，所以 h + 1，直到 h 无法再继续增大。</p>
<h3 id="方法二：计数排序"><a href="#方法二：计数排序" class="headerlink" title="方法二：计数排序"></a>方法二：计数排序</h3><p>根据上述解法我们发现，最终的时间复杂度与排序算法的时间复杂度有关，所以我们可以使用计数排序算法，新建并维护一个数组 counter 用来记录当前引用次数的论文有几篇。counter[i] 代表引用次数大于等于 i 的论文数目。<br>且依题意，h指数不能大于论文总数，所以对于超过论文总数的发表次数，我们可以将其被引用次数视为论文总数来计算，这样我们可以限制参与排序的数的范围就是 [0, n]，使得计数排序的时间复杂度降低到 O(n)。<br>最后我们可以从后向前遍历数组 counter，对于每个 0 ≤ i ≤ n，在数组 counter 中得到大于或等于当前引用次数 i 的总论文数。当我们找到第一个 h 指数时跳出循环（从后找到的第一个 h 必是满足条件的最大值），并返回结果。</p>
<h3 id="方法三：二分"><a href="#方法三：二分" class="headerlink" title="方法三：二分"></a>方法三：二分</h3><p>我们需要找到一个值 h，它是满足[有 h 篇论文被引用次数大于等于 h]的最大值。小于等于 h 的所有值 x 都满足这个性质，而大于等于 h 的所有值 y 都不满足这个性质，且我们可以通过较短的时间 O(n) 遍历一遍数组来判断 x 是否满足这个性质，所以可以用二分的方法来解决这个问题。<br>设查找范围的初始左边界 left 为 0，表示 h 指数的最小可能值为0；初始右边界 right 为 n，表示 h 指数的最大可能值为数组的长度。每次在查找范围内取中点 mid（mid 相当于当前验证的h值），同时扫描整个数组，计算大于等于 mid 的个数 cnt。如果 cnt 大于等于 mid，说明 h 可能的取值范围是 [mid, n];如果 cnt 小于 mid，说明 h 可能的取值范围是 [0, mid - 1]。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题解一：排序"><a href="#题解一：排序" class="headerlink" title="题解一：排序"></a>题解一：排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">HIndex</span>(<span class="params"><span class="built_in">int</span>[] citations</span>)</span> &#123;</span><br><span class="line">    Array.Sort(citations);</span><br><span class="line">    <span class="built_in">int</span> h = <span class="number">0</span>, n = citations.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(citations[i] &gt; h) &#123;</span><br><span class="line">            h ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解二：计数排序"><a href="#题解二：计数排序" class="headerlink" title="题解二：计数排序"></a>题解二：计数排序</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">HIndex</span>(<span class="params"><span class="built_in">int</span>[] citations</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n = citations.Length, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>[] counter = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(citations[i] &gt;= n) &#123;</span><br><span class="line">            counter[n] ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter[citations[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = n; i &gt;- <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tot += counter[i];</span><br><span class="line">        <span class="keyword">if</span>(tot &gt;= i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解三：二分"><a href="#题解三：二分" class="headerlink" title="题解三：二分"></a>题解三：二分</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">HIndex</span>(<span class="params"><span class="built_in">int</span>[] citations</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">0</span>, right = citations.Length;</span><br><span class="line">    <span class="built_in">int</span> mid = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">//向上取整避免死循环</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; citations.Length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(citations[i] &gt;= mid) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= mid) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>排序</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + github 博客搭建</title>
    <url>/2023/10/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo+Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>记录使用Hexo+Github搭建博客的详细步骤，包含了环境安装、博客搭建、远程部署、主题更换四个部分的内容。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p><strong>git：</strong> git是一个开源的<strong>分布式版本控制系统</strong>，用以有效、高速地处理从非常小到非常大的项目版本管理。</p>
</li>
<li><p><strong>github：</strong> 一个基于 Git 的代码托管平台，它提供了一种集中式和协作式的方式，让开发者能够存储、管理、追踪和协作开发软件项目。。</p>
</li>
<li><p><strong>Github Pages：</strong> GitHub 提供的一个免费静态网站托管服务，允许用户创建和托管个人、团队或项目的静态网站，支持HTML和MarkDown类型的静态文件。Github Pages三个特点：免费托管、自带主题、支持自制页面和Jekyll。</p>
<p>GitHub Pages 的设计理念之一是提供一个用户友好的方式来展示项目或个人信息，以减轻新手在 GitHub 上阅读源码时的困难。通过自定义项目首页，用户可以为他们的项目创建简洁、易懂的网页，提供项目的概述、用法说明、示例、文档和其他有关信息。这有助于提高项目的可访问性，使其他开发者更容易理解和使用项目。</p>
<p>GitHub Pages 还非常适合博客、个人网站和在线履历。许多开发者和创作者使用 GitHub Pages 来分享技术文章、个人作品和项目文档。由于它的简单性和集成性，GitHub Pages 成为了一个非常受欢迎的方式来托管静态内容，并将其与 GitHub 存储库集成在一起。</p>
</li>
<li><p><strong>为什么使用Github Pages：</strong><br>①搭建简单且免费；<br>②可以绑定自己的域名；<br>③支持静态脚本；<br>④DIY自由发挥，支持使用模板，git、markdown、bootstrap、jekyll等；<br>⑤方便使用git做版本管理。</p>
</li>
</ul>
<blockquote>
<p><strong>两种Pages类型</strong>  </p>
<p><strong>1.User&#x2F;Organization Pages个人或公司站点</strong></p>
<ul>
<li>特点：这种模式通过创建一个与用户或组织名称相对应的仓库，然后在该仓库中创建一个名为 gh-pages 或 docs 的分支来托管网站内容。你的网站将可以通过 <a href="https://username.github.io/">https://username.github.io</a> 或 <a href="https://organizationname.github.io/">https://organizationname.github.io</a> 的方式访问，其中 username 是你的 GitHub 用户名，organizationname 是组织的名称。  </li>
<li>用途：主要用于创建个人或组织的官方网站，或者用于展示与用户&#x2F;组织相关的项目和信息、博客、作品集等。</li>
</ul>
<p><strong>2.Project Pages项目站点</strong></p>
<ul>
<li>特点：这种模式通过在特定项目的仓库中创建一个名为 gh-pages 或 docs 的分支来托管网站内容。项目页面将通过 <a href="https://username.github.io/repositoryname">https://username.github.io/repositoryname</a> 访问，其中 username 是你的 GitHub 用户名，repositoryname 是项目的名称。</li>
<li>用途：主要用于创建与项目相关的二级应用页面，用于项目文档、演示、展示和其他相关信息。每个 GitHub 仓库都可以启用此功能，使项目的文档和演示更容易分享和访问。</li>
</ul>
<p>这种组织方式允许将主站和项目页面进行有效分离，使用者可以专注于在主站上展示个人或组织信息，同时在项目页面上为不同的项目提供特定的文档或演示。这样的架构有助于保持项目之间的独立性和整洁性。</p>
</blockquote>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><h4 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h4><p>官方地址：<a href="https://">https://git-scm.com/</a><br>访问官方地址，下载对应的安装包，进行安装即可（一直点击下一步）。</p>
<h4 id="验证git"><a href="#验证git" class="headerlink" title="验证git"></a>验证git</h4><p>安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开。输入 <code>git –-version</code>或<code>git -v</code>，出现版本号说明安装成功。</p>
<p><img src="/../images/pic1/20221204_195202_pic1.png" alt="查看Git版本"></p>
<h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><h4 id="下载Node"><a href="#下载Node" class="headerlink" title="下载Node"></a>下载Node</h4><p>官方地址：<a href="https://">https://nodejs.org/en/</a></p>
<p>访问Node官网，下载适合自己windows的版本，安装过程中一直点下一步。在Custom Setup这一步的时候，选择Add to Path（有的时候这个选项是默认的）。</p>
<h4 id="验证Node"><a href="#验证Node" class="headerlink" title="验证Node"></a>验证Node</h4><p>安装好以后，打开cmd命令窗口，输入 <code>npm –v</code>，出现版本号则说明安装成功且环境变量已经配置好了。</p>
<p><img src="/../images/pic1/20221204_195900_pic2.png" alt="查看Node版本"></p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><h4 id="下载Hexo"><a href="#下载Hexo" class="headerlink" title="下载Hexo"></a>下载Hexo</h4><p>这一步可以使用git bash来安装，也可以直接使用cmd窗口，命令是一样的。官方地址：<a href="https://">https://nodejs.org/en</a></p>
<p><code>npm install -g hexo-cli</code></p>
<h4 id="验证Hexo"><a href="#验证Hexo" class="headerlink" title="验证Hexo"></a>验证Hexo</h4><p>安装完成后输入 <code>hexo –v</code>，出现一系列版本号就说明安装成功了。</p>
<p><img src="/../images/pic1/20221204_200230_pic3.png" alt="查看Hexo版本"></p>
<h2 id="创建个人站点"><a href="#创建个人站点" class="headerlink" title="创建个人站点"></a>创建个人站点</h2><h3 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h3><p><img src="/../images/pic1/20221204_202240_pic4.png" alt="新建仓库"></p>
<p>仓库的名字填写username&lt;用户名&gt;.github.io，权限默认是public，所有人都可以访问我们的仓库；如果想要创建私人权限的仓库，选择“private”。</p>
<p><img src="/../images/pic1/20221204_230931_pic19.png" alt="填写仓库名字"></p>
<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>进入仓库，点击创建文件。</p>
<p><img src="/../images/pic1/20221204_231416_pic6.png" alt="创建文件"></p>
<p>创建一个新的文件，名字叫做index.html（必须叫这个，静态http文件托管服务的默认访问文件就是index.html）。<br>查看网址，选择“Settings”，找到“Pages”。</p>
<p><img src="/../images/pic1/20221204_231854_pic18.png" alt="查看网址"></p>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>现在开始可以使用hexo来生成一个博客了。<br>在本地创建一个文件夹，用于存储博客的本地数据。<br>cd到这个文件夹下，运行命令 <code>hexo init</code>，hexo会将这个文件夹初始化成一个博客专用文件夹，这个过程会花费一些时间。</p>
<p><img src="/../images/pic1/20221204_212425_pic10.png" alt="初始化博客文件夹"></p>
<p>初始化完成后，可以在source文件夹中看到一个叫hello-world的默认文章，还会有一个默认主题。先生成博客看一下效果，运行命令：<br><code>hexo generate</code>或是简写成 <code>hexo g</code>。</p>
<p><img src="/../images/pic1/20221204_212531_pic11.png" alt="查看效果"></p>
<p>然后hexo会开始生成博客，生成结束后，原文件下多了一个public文件夹，这个文件夹是hexo生成的一个完整的静态网站，也就是我们的博客。网站生成好后，我们可以启动服务器来浏览博客，运行命令：<code>hexo server</code>。</p>
<p><img src="/../images/pic1/20221204_213120_pic12.png" alt="浏览博客"></p>
<p>打开浏览器，输入localhost:4000就可以浏览博客了。</p>
<p><img src="/../images/pic1/20221204_213408_pic13.png" alt="本地浏览博客"></p>
<blockquote>
<p>Tips：如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p>
<p>Hexo 博客文件夹目录结构如下：</p>
<p><img src="/../images/pic1/20221204_213953_pic14.png" alt="Hexo博客文件夹目录"></p>
</blockquote>
<h2 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h2><p>此时运行的服务器，是我们的本地服务器，只有在本机上才可以访问。为了让别人能访问我们的博客，需要进行远程部署，将我们生成好的博客部署到远程仓库去。如果远程仓库支持pages服务，就可以通过这样的方法发布和更新博客。</p>
<p>在博客文件夹内右键，点击Git Bash here。</p>
<p>初始化git仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>配置github账户信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Github用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;Github邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>继续输入以下命令来生成关联邮箱的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen –t rsa –C <span class="string">&quot;Github邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>按git给出的路径，找到id_rsa.pub文件，并复制其中的内容（用记事本就可以打开）。<br>如果电脑上找不到.ssh文件，使用下边的命令来生成(<strong>记得再执行一次前一条命令</strong>)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen –o</span><br></pre></td></tr></table></figure>

<p>进到仓库，点击右上角setting进入设置。Title随便写，Key的内容填刚才id_rsa.pub文件中复制的内容。</p>
<p><img src="/../images/pic1/20221204_220509_pic15.png" alt="设置key"></p>
<p>校验ssh key是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p><img src="/../images/pic1/20221205_000741_pic20.png" alt="校验key是否成功"></p>
<p>修改博客目录配置文件（_congif.yml）中的deploy字段，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Git仓库地址</p>
<p><img src="/../images/pic1/20221204_221355_pic16.png" alt="修改deploy字段"></p>
</blockquote>
<p>要使用远程部署，需要先安装 <code>hexo-deployer-git</code>，这是适用于git类型仓库的方法。cd到博客文件夹后运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  <span class="comment">#安装部署工具</span></span><br></pre></td></tr></table></figure>

<p>验证：在你的 Hexo 项目目录中，打开 package.json 文件。在这个文件中，你可以找到项目的依赖项列表，查看是否包含了 hexo-deployer-git。</p>
<p>把本地仓库部署到云端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><strong>如果成功部署到github，却访问不了网站，重启路由器。</strong></p>
<h2 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h2><p>hexo主题网站：<a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a><br>找到博客文件夹的themes文件夹，这是存放博客主题的文件夹。<br><img src="/../images/pic1/themes.png" alt="themes文件夹"><br>挑选一个喜欢的博客主题，进入到对应的git仓库，并下载到本地来（具体可以参考每个主题的README文档），也可以直接下载压缩包，解压到themes文件夹。<br><img src="/../images/pic1/zip.png" alt="zip下载">  </p>
<blockquote>
<p>Tips:</p>
<ul>
<li>在博客文件夹下打开git命令窗口，执行相关指令；</li>
<li>按照README执行指令时，如果使用git clone命令时出现了<code> OpenSSL SSL_read: Connection was reset, errno 10054</code>报错，看下是否是README是否没更新https。</li>
</ul>
</blockquote>
<p>确认已经下载好主题到themes文件夹后，打开博客文件夹下的_config.yml文件，修改theme为你所选主题的对应文件夹名，示例：<code>theme:next</code></p>
<blockquote>
<p>Tips:每个主题文件夹下也有一个_config.yml文件，这是该主题的配置文件，按照主题文档修改即可，不要和博客的_config.yml搞混了。</p>
</blockquote>
<p>然后执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  <span class="comment">#清除缓存</span></span><br><span class="line">hexo g  <span class="comment">#生成静态界面</span></span><br><span class="line">hexo d  <span class="comment">#部署到github</span></span><br></pre></td></tr></table></figure>

<p>再次打开对应站点应该就可以看到页面被更换为了新主题。也可以启动hexo服务器后访问<code>localhost:4000</code>本地查看后再部署。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章发布流程</title>
    <url>/2023/10/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>简单介绍下将文章发布到博客，并且放到对应的目录下，同时添加相应标签的流程。</p>
<span id="more"></span>
<h2 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h2><p>在hexo博客根目录，使用git bash创建一篇新文章<code>hexo new post &quot;your-article-title&quot;</code>，替换”your-article-title”为文章的标题。打开刚创建的 Markdown 文件，使用 Markdown 语法编写文章内容。<br>如果有已经写好的markdown文件，直接复制到 &#x2F;source&#x2F;_posts 文件夹下。</p>
<blockquote>
<p>注意：<br>如果直接复制的md文件引用了图片，记得把图片一并放到博客文件夹下，可以自己整理目录结构，例如在 source 文件夹下建立 images 文件夹，images 文件夹里又可以创建子文件夹，分别存储每篇博文的引用图片。<br>markdown文件里的图片引用地址也要替换为图片和博文的相对地址,例如..&#x2F;images&#x2F;blog1&#x2F;pic1.png。</p>
</blockquote>
<h2 id="为文章添加标签和分类"><a href="#为文章添加标签和分类" class="headerlink" title="为文章添加标签和分类"></a>为文章添加标签和分类</h2><p>在博文最开头添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line"><span class="built_in">date</span>: 发布时间</span><br><span class="line">description: 摘要。也可以不写，而是在文章中想要截断的地方加入 &lt;!-- more --&gt; ，这样首页就只会显示截断之前的内容，而不显示全文</span><br><span class="line">categories:</span><br><span class="line">  - 分类</span><br><span class="line">  - 子分类</span><br><span class="line">tags:</span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>在博客根目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>博文就被推到博客相关的目录下了，并且已经加上了对应的标签。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题配置和优化</title>
    <url>/2023/10/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/NexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>修改NexT主题的配置，并添加一些常见的功能，让博客页面更加美观，功能更加齐全。</p>
<span id="more"></span>

<h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>在站点配置文件_config.yml中修改博客的基本信息，如标题，副标题，描述，作者等。此时要执行<code>hexo g</code>和<code>hexo s</code>之后才能刷新在本地看到效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: tsq的博客</span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span></span><br><span class="line">keywords: <span class="string">&quot;C#, C++, Lua, Unity, 数据结构, 算法&quot;</span></span><br><span class="line">author: TongShuqi</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>Next是常用的hexo主题，之前已经讲过如何使用新主题，今天说一下如何配置和优化NexT主题，修改配置需要修改NexT主题的_config.yml文件（区分于博客站点的配置文件，以下称为<strong>主题配置文件</strong>）。<br>查看配置修改效果只需要启动hexo服务器（在博客文件夹下打开git命令行，执行<code>hexo s</code>）,修改配置保存后通过<code>localhost:4000</code>刷新查看即可（部分内容需要重新hexo g生成静态文件才能看到效果）。  </p>
<h3 id="修改Schemes"><a href="#修改Schemes" class="headerlink" title="修改Schemes"></a>修改Schemes</h3><p>Next有四种主题，通过修改<code>scheme</code>来进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scheme: Muse</span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h3 id="设置站点icon"><a href="#设置站点icon" class="headerlink" title="设置站点icon"></a>设置站点icon</h3><p>一个常用的icon下载地址：<a href="https://www.iconfont.cn/">iconfont</a>。</p>
<ul>
<li>把下载好的icon图片放在 &#x2F;themes&#x2F;next&#x2F;source&#x2F;img&#x2F; 文件夹下。</li>
<li>修改主题配置文件中<code>favicon</code>的内容，也可以直接替换图片。</li>
</ul>
<h3 id="设置菜单栏选项"><a href="#设置菜单栏选项" class="headerlink" title="设置菜单栏选项"></a>设置菜单栏选项</h3><p>修改<code>menu</code>中的内容，把需要的菜单栏取消注释即可。</p>
<h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>菜单栏配置修改完后，需要分别创建菜单栏页面。</p>
<ul>
<li><p>在博客文件夹下打开git命令窗口，执行以下命令。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>以目录为例，执行命令后，成功会显示<code>INFO  Created: ~/Documents/blog/source/categories/index.md</code>，可以在source文件夹下看见这几个新生成的目录。</p>
</li>
<li><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line"><span class="built_in">date</span>: 2023-10-20 22:55:09</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加<code>type</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line"><span class="built_in">date</span>: 2023-10-20 22:55:09</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>按这种方式为tags添加type。</p>
</li>
<li><p>同理，我们也可以自己创建菜单，使用以上命令，并在配置文件的<code>menu</code>中添加即可。</p>
</li>
</ul>
<h3 id="修改博客头像"><a href="#修改博客头像" class="headerlink" title="修改博客头像"></a>修改博客头像</h3><p>保存图片到 &#x2F;themes&#x2F;next&#x2F;source&#x2F;img&#x2F; 文件夹下，在主题配置文件中修改<code>avatar</code>的内容，填写url路径即可。</p>
<h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><p>当博客文章变多后，找到一篇文章就很困难。NexT支持为博客添加搜索功能，可以通过文章内容词汇快速搜索。</p>
<ul>
<li>在博客根目录打开黑窗口输入命令：</li>
</ul>
<p><code>npm install hexo-generator-search --save</code></p>
<ul>
<li><p>修改<strong>站点配置文件</strong>,加入以下内容（选项内容可适当修改）：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 1000</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<strong>主题配置文件</strong>：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置社交界面"><a href="#设置社交界面" class="headerlink" title="设置社交界面"></a>设置社交界面</h3><p>可以添加一些常用的社交链接，例如Github、Twitter、CSDN等，也可以自定义链接。</p>
<ul>
<li>在主题配置文件中修改<code>social</code>字段，把想要展示的内容取消注释。</li>
<li>也可以自己添加，格式为:显示文本: 链接地址 || Front Awesome图标名称</li>
</ul>
<h3 id="添加阅读时间和字数提示"><a href="#添加阅读时间和字数提示" class="headerlink" title="添加阅读时间和字数提示"></a>添加阅读时间和字数提示</h3><p>Hexo支持添加单篇文章和全站点的阅读时间及字数提示。步骤如下：</p>
<ul>
<li><p>博客根目录黑窗口下载插件：<br><code>npm install hexo-symbols-count-time</code></p>
</li>
<li><p>在站点配置文件末尾加入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span></span><br><span class="line">  time: <span class="literal">true</span></span><br><span class="line">  total_symbols: <span class="literal">true</span></span><br><span class="line">  total_time: <span class="literal">true</span></span><br><span class="line">  exclude_codeblock: <span class="literal">false</span></span><br><span class="line">  awl: 2    </span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span></span><br><span class="line">  item_text_total: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="添加阅读人次统计"><a href="#添加阅读人次统计" class="headerlink" title="添加阅读人次统计"></a>添加阅读人次统计</h3><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="去掉网页Hexo自带底部信息"><a href="#去掉网页Hexo自带底部信息" class="headerlink" title="去掉网页Hexo自带底部信息"></a>去掉网页Hexo自带底部信息</h3><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powered: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="右上角实现github按钮"><a href="#右上角实现github按钮" class="headerlink" title="右上角实现github按钮"></a>右上角实现github按钮</h3><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/yourname</span><br></pre></td></tr></table></figure>

<h3 id="配置回到顶部按钮"><a href="#配置回到顶部按钮" class="headerlink" title="配置回到顶部按钮"></a>配置回到顶部按钮</h3><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>边栏和滚动百分比可以按照需求自行添加。</p>
<h3 id="添加已读进度条"><a href="#添加已读进度条" class="headerlink" title="添加已读进度条"></a>添加已读进度条</h3><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>进度条的位置，颜色，高度等属性可以自行设置。</p>
<h3 id="配置代码样式"><a href="#配置代码样式" class="headerlink" title="配置代码样式"></a>配置代码样式</h3><p>在主题配置文件中搜索<code>codeblock</code>，按需求进行样式修改即可。</p>
<h3 id="更改背景图片"><a href="#更改背景图片" class="headerlink" title="更改背景图片"></a>更改背景图片</h3><ul>
<li><p>在主题配置文件中找到<code>custom_file_path</code>，把<code>style</code>取消注释。</p>
</li>
<li><p>在博客根目录的 source 文件夹下新建 _data 文件夹（不是主题目文件夹的 source）。</p>
</li>
<li><p>文件夹里新建 styles.styl 文件。</p>
</li>
<li><p>styles 文件里加入如下内容，注意图片要放在next文件夹的next&#x2F;source&#x2F;images下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//背景图片设置</span><br><span class="line">body &#123;</span><br><span class="line">    background-image: url(/images/background.jpg); </span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment: fixed;</span><br><span class="line">    background-size: 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置边框圆角矩形"><a href="#设置边框圆角矩形" class="headerlink" title="设置边框圆角矩形"></a>设置边框圆角矩形</h3><ul>
<li><p>在主题配置文件中找到<code>custom_file_path</code>，把<code>variable</code>取消注释。</p>
</li>
<li><p>主题文件夹的 source 文件夹里新建 variables.styl 文件。</p>
</li>
<li><p>variables 文件里加入如下内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 圆角设置</span><br><span class="line"><span class="variable">$border</span>-radius-inner     = 30px 30px 30px 30px;</span><br><span class="line"><span class="variable">$border</span>-radius           = 30px;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="打赏功能添加"><a href="#打赏功能添加" class="headerlink" title="打赏功能添加"></a>打赏功能添加</h3><ul>
<li><p>首先需要有一个微信或支付宝的二维码图片，放在 &#x2F;next&#x2F;source&#x2F;images 下。</p>
</li>
<li><p>修改主题配置文件，会在每篇文章末尾生成一个打赏按钮，可以根据情况选择打赏方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line"><span class="comment"># If true, a donate button will be displayed in every article by default.</span></span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">animation: <span class="literal">false</span></span><br><span class="line">comment: づ♡ど</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="评论功能添加"><a href="#评论功能添加" class="headerlink" title="评论功能添加"></a>评论功能添加</h3><p>NexT 主题支持多种评论系统，如Disqus、GitTalk等。<br>这里介绍使用 gitalk 和 utterances 来实现评论功能。</p>
<h4 id="gitalk"><a href="#gitalk" class="headerlink" title="gitalk"></a>gitalk</h4><p>PS：官方服务器已炸，现在不能直接用了，建议使用别的评论系统，此时仅作记录，之后有时间再研究解决方案。</p>
<ul>
<li><p>在开始之前，你需要创建一个 GitHub OAuth App。这将用于 Gittalk 连接到你的 GitHub 仓库。<br>登陆到自己的GitHub账户，点击头像-Settings-Developer settings。</p>
</li>
<li><p>在 “Developer settings” 页面上，点击 “OAuth Apps” 选项卡，然后点击注册按钮。</p>
</li>
<li><p>在 “Register a new OAuth application” 页面上，填写 OAuth App 的详细信息:<br>Application name：应用名称，随便写。<br>Homepage URL：博客主页。<br>Application description：应用的简短描述。<br>Authorization callback URL：回调 URL，可以是博客主页。</p>
</li>
<li><p>获取 Client ID 和 Client Secret：<br>在成功创建 OAuth App 后，你会看到一个页面，其中包含你的 OAuth App 的详细信息，包括 “Client ID” 和 “Client Secret”。这些是你的 OAuth App 的凭证，将用于与 GitHub 进行授权。<br><img src="/../images/pic2/pic1.png" alt="OAuth"></p>
</li>
<li><p>在主题配置文件中，修改如下配置（NexT8内置了gittalk，无需安装）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  github_id: <span class="comment"># GitHub 仓库的所有者（repo owner）的用户名</span></span><br><span class="line">  repo: <span class="comment"># 存储评论的 GitHub 仓库的名称</span></span><br><span class="line">  client_id: <span class="comment"># OAuth App 的 Client ID </span></span><br><span class="line">  client_secret: <span class="comment"># OAuth App 的 Client Secret</span></span><br><span class="line">  admin_user: <span class="comment"># 评论管理者的 GitHub 用户名，通常是你自己，以便你可以管理评论</span></span><br><span class="line">  distraction_free_mode: <span class="literal">true</span> <span class="comment"># Facebook-like</span></span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  style: tabs</span><br><span class="line">  active: gitalk</span><br><span class="line">  storage: <span class="literal">true</span></span><br><span class="line">  lazyload: <span class="literal">false</span></span><br><span class="line">  nav:</span><br><span class="line">    gitalk:</span><br><span class="line">    order: -1</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署完成后，登录博客，任一一篇博文下应该变成了<br><img src="/../images/pic2/pic2.png" alt="issue"></p>
</li>
<li><p>登录，验证。应该能看到评论了。假如出现：<br><img src="/../images/pic2/pic3.png" alt="issue"><br>查一下主题配置文件中gitalk的proxy是不是 <code>https://github.com/login/oauth/access_token</code> 。<br>如果是，改为 <code>https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</code> 。</p>
</li>
</ul>
<h4 id="utterances"><a href="#utterances" class="headerlink" title="utterances"></a>utterances</h4><p>同样是依托于 github 的 issue 做评论区，但是索取的权限更少，也不需要指定某个人来初始化，因此好用得多。较新版本的NexT已经集成了utterances，使用非常简单。</p>
<ul>
<li><p>新建一个仓库用于存储博客评论。</p>
</li>
<li><p>授权<a href="https://github.com/apps/utterances">utterances</a>，选择建立的仓库。</p>
</li>
<li><p>在主题配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  style: tabs</span><br><span class="line">  active: utterances <span class="comment">#激活utterances</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">utterances:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  repo: tsq0316/blog-comments <span class="comment"># Your Github repository owner and name</span></span><br><span class="line">  issue_term: title</span><br><span class="line">  label: utteranc</span><br><span class="line">  theme: github-light</span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点配置文件中进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url: http://tsq0316.github.io/ <span class="comment"># Your Github site</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
